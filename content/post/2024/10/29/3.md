+++
date = '2024-10-29T17:24:49+09:00'
draft = false
title = 'データ移行のためのより優れた拡張可能なシステムの構築'
+++


[Building a better and scalable system for data migrations](https://yorickpeterse.com/articles/building-a-better-and-scalable-system-for-data-migrations/)


# データ移行のためのより優れた拡張可能なシステムの構築
2024年10月24日

最近、新しいRustのWebフレームワーク「rwf」に興味を持ち、特にデータベース移行の方法に注目した。だが、このフレームワークは他の多くのフレームワーク同様、移行が大規模になると対応が困難になる。GitLabの例を通じて、規模拡大での移行の課題を説明し、それを解決するための具体的な手法を提案する。
<!--more-->
## 提案する改善案

1. **移行をプログラミング関数として記述する**
   SQLスニペットではなく、RubyやRustなどのプログラミング言語で実装することで、柔軟性を確保する。

2. **VCSリビジョンに基づく移行の実行**
   コードの状態に依存しない移行を実現し、テストや保守性を向上させる。これにより、アプリケーションロジックの重複も防げる。

3. **事前・事後移行の分離**
   GitLabの事例のように、事前移行で後方互換性を保ち、事後移行で不要な要素を削除する。

4. **大規模データの移行**
   並列処理とバックグラウンドジョブを使い、負荷分散を行う。これにより、移行が長時間に及ぶ場合でも運用を継続できる。

5. **移行テストの容易化**
   初期状態からの移行を再現するテストを導入し、移行が正しく動作することを確認できるようにする。

## GitLabの実例

GitLabでは、最初はRuby on Railsの移行フレームワークを使っていたが、データベースのサイズが大きくなるにつれて従来の方法では非効率になった。特に、カラムのリネームや大規模なデータ移行は、伝統的なRailsのアプローチでは数週間かかることもあった。そのため、以下の解決策が取られた。

- **事前移行と事後移行の分割**：事前移行では互換性のある変更のみを行い、事後移行で不要なデータを削除する。
- **バックグラウンドジョブの使用**：Sidekiqを使って長時間かかる移行をバックグラウンドで実行する。
- **アプリケーションロジックからの独立**：移行のたびに必要なコードをスナップショットとして保持し、他のアプリケーションロジックから分離する。

## 現行の移行システムが抱える問題

1. **タイムレスでない**：移行がアプリケーションの最新の状態に依存するため、途中でロジックが変わると移行が失敗する可能性がある。
2. **スケールしない**：小規模な移行には対応できるが、大規模なシステムには不十分。
3. **プロジェクト間で異なる要件**：小さなSQLiteを使うアプリと、10TiBのデータを持つSaaSでは移行の要件が大きく異なる。

## どうやってより良いシステムを構築するか

- **移行を関数として実装**：SQLファイルに頼らず、プログラム言語で記述し、双方向の移行を実現する。
- **VCSリビジョンで移行を管理**：各移行が特定のリビジョンに対応することで、タイムレスな移行を保証する。
- **事前・事後移行の適用**：GitLabの手法を参考に、後方互換性を保ちながら、必要な変更を段階的に適用する。
- **大規模データ移行の支援**：負荷を分散し、バックグラウンドでジョブを実行する仕組みを提供する。
- **移行テストを容易にする**：テスト用のプリミティブを提供し、移行が正しく動作するかを検証できるようにする。

## 結論

この提案は、移行システムをより効果的かつスケーラブルにするための一案だ。特に、VCSリビジョンに基づく移行は注目に値し、今後自分がWebフレームワークを開発する際に、このアイデアを試してみたいと考えている。

---
この話の流れが面白い
[GitLab.com database incident](https://about.gitlab.com/blog/2017/02/01/gitlab-dot-com-database-incident/)
