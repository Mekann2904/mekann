/**
 * @abdd.meta
 * path: tests/unit/lib/embeddings/registry.property.test.ts
 * role: Property-based tests for EmbeddingProviderRegistry invariants
 * why: Verify system invariants hold for all possible inputs
 * related: .pi/lib/embeddings/registry.ts, registry.test.ts
 * public_api: None (test file)
 * invariants: Uses fast-check for exhaustive property testing
 * side_effects: None (pure property tests)
 * failure_modes: Property violations indicate invariant bugs
 * @abdd.explain
 * overview: Property-based tests using fast-check to verify invariants
 * what_it_does: Tests mathematical properties that should always hold
 * why_it_exists: Catch edge cases that example-based tests miss
 * scope:
 *   in: Arbitrary inputs generated by fast-check
 *   out: Specific examples that violate properties
 */

import { describe, it, expect } from "vitest";
import * as fc from "fast-check";

// =============================================================================
// Property Definitions
// =============================================================================

/**
 * Valid provider ID
 */
const validProviderId = fc
  .string({ minLength: 1, maxLength: 50 })
  .filter((s) => /^[a-z0-9_-]+$/i.test(s));

/**
 * Valid provider name
 */
const validProviderName = fc.string({ minLength: 1, maxLength: 100 });

/**
 * Embedding dimension (common values)
 */
const embeddingDimension = fc.constantFrom(128, 256, 384, 512, 768, 1024, 1536, 3072);

/**
 * Valid embedding vector
 */
const embeddingVector = (dim: number) =>
  fc.array(fc.float({ min: -1, max: 1, noNaN: true }), {
    minLength: dim,
    maxLength: dim,
  });

/**
 * Provider status
 */
const providerStatus = fc.constantFrom("idle", "running", "error", "completed");

/**
 * Model name
 */
const modelName = fc.string({ minLength: 1, maxLength: 100 });

// =============================================================================
// Invariant Tests
// =============================================================================

describe("EmbeddingProviderRegistry Invariants", () => {
  // ---------------------------------------------------------------------------
  // Registration Invariant
  // ---------------------------------------------------------------------------

  describe("Provider Registration", () => {
    it("should maintain id uniqueness", () => {
      fc.assert(
        fc.property(
          fc.array(validProviderId, { minLength: 0, maxLength: 50 }),
          (ids) => {
            const registry = new Map<string, string>();

            for (const id of ids) {
              registry.set(id, id);
            }

            // Invariant: unique count <= input count
            expect(registry.size).toBeLessThanOrEqual(ids.length);
          }
        )
      );
    });

    it("should handle overwrite correctly", () => {
      fc.assert(
        fc.property(
          validProviderId,
          validProviderName,
          validProviderName,
          (id, name1, name2) => {
            const registry = new Map<string, string>();

            registry.set(id, name1);
            registry.set(id, name2);

            // Invariant: last write wins
            expect(registry.get(id)).toBe(name2);
            expect(registry.size).toBe(1);
          }
        )
      );
    });
  });

  // ---------------------------------------------------------------------------
  // Lookup Invariant
  // ---------------------------------------------------------------------------

  describe("Provider Lookup", () => {
    it("should return undefined for non-existent providers", () => {
      fc.assert(
        fc.property(validProviderId, (id) => {
          const registry = new Map<string, string>();
          // Empty registry

          const result = registry.get(id);

          // Invariant: lookup in empty registry returns undefined
          expect(result).toBeUndefined();
        })
      );
    });

    it("should maintain get/set consistency", () => {
      fc.assert(
        fc.property(validProviderId, validProviderName, (id, name) => {
          const registry = new Map<string, string>();

          registry.set(id, name);
          const result = registry.get(id);

          // Invariant: get returns what was set
          expect(result).toBe(name);
        })
      );
    });
  });

  // ---------------------------------------------------------------------------
  // Embedding Vector Invariants
  // ---------------------------------------------------------------------------

  describe("Embedding Vectors", () => {
    it("should validate vector dimensions", () => {
      fc.assert(
        fc.property(embeddingDimension, (dim) => {
          // Invariant: dimension should be positive
          expect(dim).toBeGreaterThan(0);

          // Invariant: dimension should be power of 2 or common value
          const commonDims = [128, 256, 384, 512, 768, 1024, 1536, 3072];
          expect(commonDims).toContain(dim);
        })
      );
    });

    it("should handle vector normalization", () => {
      fc.assert(
        fc.property(
          fc.array(fc.float({ min: -10, max: 10, noNaN: true }), {
            minLength: 1,
            maxLength: 100,
          }),
          (vector) => {
            // Calculate L2 norm
            const norm = Math.sqrt(
              vector.reduce((sum, v) => sum + v * v, 0)
            );

            // Normalize
            const normalized = vector.map((v) => v / (norm || 1));

            // Invariant: normalized vector has unit length (approximately)
            const newNorm = Math.sqrt(
              normalized.reduce((sum, v) => sum + v * v, 0)
            );

            if (norm > 0) {
              expect(newNorm).toBeCloseTo(1, 5);
            }
          }
        )
      );
    });

    it("should calculate cosine similarity correctly", () => {
      fc.assert(
        fc.property(
          fc.array(fc.float({ min: -1, max: 1, noNaN: true }), {
            minLength: 2,
            maxLength: 10,
          }),
          (vec) => {
            // Same vector should have similarity 1
            const dot = vec.reduce((sum, v) => sum + v * v, 0);
            const norm1 = Math.sqrt(dot);
            const norm2 = Math.sqrt(dot);
            const similarity = dot / (norm1 * norm2 || 1);

            // Invariant: self-similarity is 1
            if (norm1 > 0) {
              expect(similarity).toBeCloseTo(1, 5);
            }
          }
        )
      );
    });
  });

  // ---------------------------------------------------------------------------
  // Availability Invariant
  // ---------------------------------------------------------------------------

  describe("Provider Availability", () => {
    it("should filter available providers correctly", () => {
      fc.assert(
        fc.property(
          fc.array(
            fc.record({
              id: validProviderId,
              available: fc.boolean(),
            }),
            { minLength: 0, maxLength: 20 }
          ),
          (providers) => {
            const available = providers.filter((p) => p.available);

            // Invariant: filtered count <= total count
            expect(available.length).toBeLessThanOrEqual(providers.length);

            // Invariant: all filtered providers are available
            expect(available.every((p) => p.available)).toBe(true);
          }
        )
      );
    });
  });

  // ---------------------------------------------------------------------------
  // Status Invariant
  // ---------------------------------------------------------------------------

  describe("Provider Status", () => {
    it("should track status transitions", () => {
      fc.assert(
        fc.property(providerStatus, providerStatus, (from, to) => {
          // Any status can transition to any status (no restrictions)
          const validTransitions = true;

          // Invariant: status is always a valid value
          const validStatuses = ["idle", "running", "error", "completed"];
          expect(validStatuses).toContain(from);
          expect(validStatuses).toContain(to);
        })
      );
    });
  });
});

// =============================================================================
// Concurrency Property Tests
// =============================================================================

describe("Concurrency Properties", () => {
  it("should handle concurrent registrations safely", () => {
    fc.assert(
      fc.property(
        fc.array(validProviderId, { minLength: 1, maxLength: 10 }),
        (ids) => {
          const registry = new Map<string, string>();

          // Simulate concurrent registrations
          for (const id of ids) {
            registry.set(id, `provider-${id}`);
          }

          // Invariant: all unique ids are registered
          const uniqueIds = new Set(ids);
          expect(registry.size).toBe(uniqueIds.size);
        }
      )
    );
  });

  it("should handle concurrent reads during writes", () => {
    fc.assert(
      fc.property(
        fc.record({
          id: validProviderId,
          name: validProviderName,
          readBeforeWrite: fc.boolean(),
        }),
        ({ id, name, readBeforeWrite }) => {
          const registry = new Map<string, string>();

          if (readBeforeWrite) {
            registry.get(id); // Read before write
          }

          registry.set(id, name);
          const result = registry.get(id);

          // Invariant: final read returns last written value
          expect(result).toBe(name);
        }
      )
    );
  });
});

// =============================================================================
// Edge Case Property Tests
// =============================================================================

describe("Edge Cases", () => {
  it("should handle empty provider lists", () => {
    fc.assert(
      fc.property(fc.constant([]), (providers) => {
        const registry = new Map<string, string>();

        for (const p of providers) {
          registry.set(p, p);
        }

        // Invariant: empty input produces empty state
        expect(registry.size).toBe(0);
      })
    );
  });

  it("should handle very long names", () => {
    fc.assert(
      fc.property(
        fc.string({ minLength: 100, maxLength: 1000 }),
        (longName) => {
          const registry = new Map<string, string>();

          // Should handle long names without error
          registry.set("test", longName);
          const result = registry.get("test");

          expect(result).toBe(longName);
        }
      )
    );
  });
});
