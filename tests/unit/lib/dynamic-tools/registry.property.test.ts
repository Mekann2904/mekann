/**
 * @abdd.meta
 * path: tests/unit/lib/dynamic-tools/registry.property.test.ts
 * role: Property-based tests for DynamicToolRegistry invariants
 * why: Verify system invariants hold for all possible inputs
 * related: .pi/lib/dynamic-tools/registry.ts, registry.test.ts
 * public_api: None (test file)
 * invariants: Uses fast-check for exhaustive property testing
 * side_effects: None (pure property tests)
 * failure_modes: Property violations indicate invariant bugs
 * @abdd.explain
 * overview: Property-based tests using fast-check to verify invariants
 * what_it_does: Tests mathematical properties that should always hold
 * why_it_exists: Catch edge cases that example-based tests miss
 * scope:
 *   in: Arbitrary inputs generated by fast-check
 *   out: Specific examples that violate properties
 */

import { describe, it, expect } from "vitest";
import * as fc from "fast-check";

// =============================================================================
// Property Definitions
// =============================================================================

/**
 * Valid tool name pattern
 */
const validToolName = fc
  .string({ minLength: 1, maxLength: 50 })
  .filter((s) => /^[a-z_][a-z0-9_]*$/i.test(s));

/**
 * Valid tool description
 */
const validDescription = fc.string({ minLength: 1, maxLength: 500 });

/**
 * Valid JavaScript identifier
 */
const validIdentifier = fc
  .string({ minLength: 1, maxLength: 30 })
  .filter((s) => /^[a-z_][a-z0-9_]*$/i.test(s));

/**
 * Parameter type
 */
const parameterType = fc.constantFrom("string", "number", "boolean", "object", "array");

/**
 * Tool parameter definition
 */
const toolParameter = fc.record({
  type: parameterType,
  description: fc.string({ maxLength: 200 }),
  required: fc.boolean(),
});

/**
 * Tool parameters schema
 */
const toolParameters = fc.record({
  properties: fc.dictionary(validIdentifier, toolParameter),
  required: fc.array(validIdentifier, { maxLength: 10 }),
});

// =============================================================================
// Invariant Tests
// =============================================================================

describe("DynamicToolRegistry Invariants", () => {
  // ---------------------------------------------------------------------------
  // Uniqueness Invariant
  // ---------------------------------------------------------------------------

  describe("Tool Name Uniqueness", () => {
    it("should maintain unique tool names in a set", () => {
      fc.assert(
        fc.property(fc.array(validToolName, { minLength: 0, maxLength: 100 }), (names) => {
          const nameSet = new Set<string>();

          for (const name of names) {
            // Invariant: adding to set should be idempotent for same name
            nameSet.add(name);
          }

          // Invariant: set size should be <= input size
          expect(nameSet.size).toBeLessThanOrEqual(names.length);
        })
      );
    });

    it("should reject duplicate names consistently", () => {
      fc.assert(
        fc.property(validToolName, validDescription, (name, description) => {
          const tools = new Map<string, { name: string; description: string }>();

          // First registration succeeds
          tools.set(name, { name, description });

          // Second registration with same name should be rejected
          const canRegister = !tools.has(name);
          expect(canRegister).toBe(false);
        })
      );
    });
  });

  // ---------------------------------------------------------------------------
  // Validation Invariant
  // ---------------------------------------------------------------------------

  describe("Tool Validation", () => {
    it("should validate name format consistently", () => {
      fc.assert(
        fc.property(fc.string({ minLength: 0, maxLength: 50 }), (name) => {
          const isValidName = /^[a-z_][a-z0-9_]*$/i.test(name) && name.length > 0;

          // Invariant: same name always produces same validation result
          const result1 = isValidName;
          const result2 = isValidName;
          expect(result1).toBe(result2);

          // Invariant: valid names don't contain special characters
          if (isValidName) {
            expect(name).not.toMatch(/[^a-z0-9_]/i);
          }
        })
      );
    });

    it("should validate parameters schema", () => {
      fc.assert(
        fc.property(toolParameters, (params) => {
          // Invariant: all required fields must exist in properties
          const allRequiredExist = params.required.every(
            (req) => req in params.properties
          );

          // This is a structural invariant
          if (params.required.length > 0 && Object.keys(params.properties).length > 0) {
            // If we have required fields and properties, the relationship should be valid
            expect(typeof allRequiredExist).toBe("boolean");
          }
        })
      );
    });
  });

  // ---------------------------------------------------------------------------
  // Execution Invariant
  // ---------------------------------------------------------------------------

  describe("Tool Execution", () => {
    it("should preserve parameter structure through serialization", () => {
      fc.assert(
        fc.property(fc.dictionary(fc.string(), fc.jsonValue()), (params) => {
          // Invariant: JSON round-trip preserves structure
          // Note: -0 and +0 are distinguished by JSON.stringify, so we use loose equality
          const serialized = JSON.stringify(params);
          const deserialized = JSON.parse(serialized);

          // Use JSON comparison to handle -0 vs +0 edge case
          expect(JSON.stringify(deserialized)).toBe(JSON.stringify(params));
        })
      );
    });

    it("should handle execution time measurement", () => {
      fc.assert(
        fc.property(fc.integer({ min: 0, max: 1000 }), (delayMs) => {
          // Invariant: execution time should be >= 0
          const executionTime = Math.max(0, delayMs);
          expect(executionTime).toBeGreaterThanOrEqual(0);
        })
      );
    });
  });

  // ---------------------------------------------------------------------------
  // State Invariant
  // ---------------------------------------------------------------------------

  describe("Registry State", () => {
    it("should maintain count invariant", () => {
      fc.assert(
        fc.property(
          fc.array(
            fc.record({
              name: validToolName,
              description: validDescription,
            }),
            { minLength: 0, maxLength: 20 }
          ),
          (tools) => {
            const uniqueNames = new Set(tools.map((t) => t.name));

            // Invariant: unique count <= total count
            expect(uniqueNames.size).toBeLessThanOrEqual(tools.length);

            // Invariant: empty input produces empty state
            if (tools.length === 0) {
              expect(uniqueNames.size).toBe(0);
            }
          }
        )
      );
    });

    it("should maintain idempotency for clear operation", () => {
      fc.assert(
        fc.property(fc.integer({ min: 0, max: 10 }), (clearCount) => {
          const registry = new Map<string, unknown>();

          // Add some items
          for (let i = 0; i < 5; i++) {
            registry.set(`tool-${i}`, { name: `Tool ${i}` });
          }

          // Clear once first
          registry.clear();

          // Clear multiple more times (should be idempotent)
          for (let i = 0; i < clearCount; i++) {
            registry.clear();
          }

          // Invariant: clear is idempotent - size should always be 0
          expect(registry.size).toBe(0);
        })
      );
    });
  });
});

// =============================================================================
// Code Safety Property Tests
// =============================================================================

describe("Code Safety Properties", () => {
  const unsafePatterns = [
    "eval(",
    "Function(",
    "require(",
    "import(",
    "process.exit",
    "child_process",
    "fs.unlinkSync",
    "fs.rmdirSync",
  ];

  it("should detect unsafe patterns in code", () => {
    fc.assert(
      fc.property(fc.string({ minLength: 0, maxLength: 1000 }), (code) => {
        const hasUnsafe = unsafePatterns.some((pattern) => code.includes(pattern));

        // Invariant: detection is consistent
        const result1 = hasUnsafe;
        const result2 = hasUnsafe;
        expect(result1).toBe(result2);
      })
    );
  });

  it("should accept safe code patterns", () => {
    fc.assert(
      fc.property(
        fc.record({
          fn: validIdentifier,
          param: validIdentifier,
          body: fc.string({ maxLength: 100 }),
        }),
        (code) => {
          const generatedCode = `export function ${code.fn}(${code.param}) { ${code.body} }`;
          const hasUnsafe = unsafePatterns.some((pattern) => generatedCode.includes(pattern));

          // Safe generated code should not trigger detection
          if (!code.body.includes("eval") && !code.body.includes("Function")) {
            expect(hasUnsafe).toBe(false);
          }
        }
      )
    );
  });
});

// =============================================================================
// Concurrency Property Tests
// =============================================================================

describe("Concurrency Properties", () => {
  it("should handle concurrent reads safely", () => {
    fc.assert(
      fc.property(
        fc.record({
          id: validToolName,
          readCount: fc.integer({ min: 1, max: 10 }),
        }),
        ({ id, readCount }) => {
          const registry = new Map<string, { name: string }>();
          registry.set(id, { name: id });

          // Simulate concurrent reads
          const results: ({ name: string } | undefined)[] = [];
          for (let i = 0; i < readCount; i++) {
            results.push(registry.get(id));
          }

          // Invariant: all reads should return same value
          const allEqual = results.every((r) => r?.name === id);
          expect(allEqual).toBe(true);
        }
      )
    );
  });
});
