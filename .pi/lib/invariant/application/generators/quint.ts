/**
 * @abdd.meta
 * path: .pi/lib/invariant/application/generators/quint.ts
 * role: Quint形式仕様コードジェネレーター
 * why: ParsedSpecからQuint形式の形式仕様記述を生成するため
 * related: ../domain/types.ts, ../parser.ts
 * public_api: generateQuintSpec
 * invariants: 出力は有効なQuint構文である
 * side_effects: なし
 * failure_modes: 不正な型の場合は警告を生成
 * @abdd.explain
 * overview: ParsedSpecからQuint形式の仕様コードを生成するジェネレーター
 * what_it_does: 状態、操作、インバリアントをQuint構文に変換する
 * why_it_exists: 形式検証のためのQuint仕様を自動生成するため
 * scope:
 *   in: ParsedSpecオブジェクト
 *   out: Quint形式の仕様コード（文字列）
 */

import type { ParsedSpec, GenerationOutput } from "../../domain/types.js";

/**
 * Map TypeScript type to Quint type
 *
 * @summary 型をQuint型に変換
 * @param type - TypeScript型名
 * @returns Quint型名
 */
function mapTypeToQuint(type: string): string {
  const typeMap: Record<string, string> = {
    "int": "int",
    "integer": "int",
    "整数": "int",
    "bool": "bool",
    "boolean": "bool",
    "真偽": "bool",
    "str": "str",
    "string": "str",
    "文字列": "str",
    "Set": "Set",
    "集合": "Set",
    "List": "List",
    "リスト": "List",
    "Map": "Map",
    "マップ": "Map",
  };
  return typeMap[type] || type;
}

/**
 * Get default value for a type
 *
 * @summary 型のデフォルト値を取得
 * @param type - 型名
 * @returns デフォルト値
 */
function getDefaultValue(type: string): unknown {
  const defaults: Record<string, unknown> = {
    "int": 0,
    "integer": 0,
    "整数": 0,
    "bool": false,
    "boolean": false,
    "真偽": false,
    "str": "",
    "string": "",
    "文字列": "",
  };
  return defaults[type] ?? null;
}

/**
 * Format value for Quint output
 *
 * @summary 値をQuint形式でフォーマット
 * @param value - 値
 * @param type - 型名
 * @returns フォーマットされた文字列
 */
function formatValue(value: unknown, type: string): string {
  if (typeof value === "string") {
    // Check if it's already a number
    if (type === "int" || type === "整数") {
      const num = parseInt(value, 10);
      if (!isNaN(num)) return num.toString();
    }
    return `"${value}"`;
  }
  return String(value);
}

/**
 * Generate Quint specification from ParsedSpec
 *
 * @summary Quint形式仕様を生成
 * @param spec - パース済み仕様
 * @param moduleName - モジュール名（省略時はタイトルから生成）
 * @returns 生成されたQuintコード
 */
export function generateQuintSpec(spec: ParsedSpec, moduleName?: string): GenerationOutput {
  const warnings: string[] = [];
  const errors: string[] = [];

  const name = moduleName || spec.title.replace(/[^a-zA-Z0-9]/g, "") || "Generated";

  let quint = `// Generated Quint specification from ${spec.title}\n`;
  quint += `// Generated by invariant-pipeline\n\n`;
  quint += `module ${name} {\n`;

  // Constants
  if (spec.constants && spec.constants.length > 0) {
    quint += `\n  // Constants\n`;
    for (const c of spec.constants) {
      quint += `  const ${c.name}: ${c.type}\n`;
    }
  }

  // State variables
  if (spec.states.length > 0) {
    quint += `\n  // State variables\n`;
    for (const s of spec.states) {
      quint += `  var ${s.name}: ${mapTypeToQuint(s.type)}\n`;
    }
  }

  // Init
  quint += `\n  // Initial state\n`;
  quint += `  init() {\n`;
  const initAssignments = spec.states.map(s => {
    const initVal = s.initialValue !== undefined ? s.initialValue : getDefaultValue(s.type);
    return `    ${s.name}' = ${formatValue(initVal, s.type)}`;
  });
  quint += initAssignments.join(",\n") + "\n";
  quint += `  }\n`;

  // Operations
  for (const op of spec.operations) {
    quint += `\n  // ${op.description || op.name}\n`;
    quint += `  action ${op.name} = all {\n`;
    // Add preconditions as guard conditions (not comments)
    if (op.preconditions && op.preconditions.length > 0) {
      for (const pre of op.preconditions) {
        quint += `    ${pre},  // guard: precondition\n`;
      }
    }
    if (op.postconditions && op.postconditions.length > 0) {
      for (const post of op.postconditions) {
        quint += `    ${post},\n`;
      }
    } else {
      warnings.push(`Operation "${op.name}" has no postconditions - generating trivially true transition`);
      quint += `    // SKIPPED: No postconditions defined for ${op.name}\n`;
      quint += `    true\n`;
    }
    quint += `  }\n`;
  }

  // Invariants
  if (spec.invariants.length > 0) {
    quint += `\n  // Invariants\n`;
    for (const inv of spec.invariants) {
      const invName = inv.name || `Invariant${spec.invariants.indexOf(inv) + 1}`;
      quint += `  invariant ${invName} {\n`;
      quint += `    ${inv.condition}\n`;
      quint += `  }\n`;
    }
  }

  quint += `}\n`;

  return { content: quint, warnings, errors };
}
