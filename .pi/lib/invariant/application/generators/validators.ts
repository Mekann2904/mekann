/**
 * @abdd.meta
 * path: .pi/lib/invariant/application/generators/validators.ts
 * role: TypeScriptインバリアントバリデーションコードジェネレーター
 * why: ParsedSpecからTypeScriptバリデーション関数を生成するため
 * related: ../domain/types.ts, ../parser.ts
 * public_api: generateTsValidators
 * invariants: 出力は有効なTypeScript構文である
 * side_effects: なし
 * failure_modes: 不正な型の場合は警告を生成
 * @abdd.explain
 * overview: ParsedSpecからTypeScriptバリデーションコードを生成するジェネレーター
 * what_it_does: インバリアント検証関数、モデルインターフェースを生成する
 * why_it_exists: 実行時インバリアント検証のためのTypeScriptコードを自動生成するため
 * scope:
 *   in: ParsedSpecオブジェクト
 *   out: TypeScript形式のバリデーションコード（文字列）
 */

import type { ParsedSpec, SpecState, GenerationOutput } from "../../domain/types.js";

/**
 * Map spec type to TypeScript type
 *
 * @summary 型をTypeScript型に変換
 * @param type - spec.mdの型名
 * @returns TypeScript型名
 */
function mapTypeToTypeScript(type: string): string {
  const typeMap: Record<string, string> = {
    "int": "number",
    "integer": "number",
    "整数": "number",
    "i64": "number",
    "i32": "number",
    "float": "number",
    "double": "number",
    "f64": "number",
    "f32": "number",
    "bool": "boolean",
    "boolean": "boolean",
    "真偽": "boolean",
    "str": "string",
    "string": "string",
    "文字列": "string",
    "List": "unknown[]",
    "リスト": "unknown[]",
    "Set": "Set<unknown>",
    "集合": "Set<unknown>",
    "Map": "Map<string, unknown>",
    "マップ": "Map<string, unknown>",
  };
  return typeMap[type] || type;
}

/**
 * Get TypeScript default value literal
 *
 * @summary TypeScriptのデフォルト値を取得
 * @param type - 型名
 * @returns デフォルト値のリテラル
 */
function getTypeScriptDefaultValue(type: string): string {
  const defaults: Record<string, string> = {
    "number": "0",
    "boolean": "false",
    "string": '""',
  };
  const tsType = mapTypeToTypeScript(type);
  return defaults[tsType] ?? "null";
}

/**
 * Translate condition to TypeScript expression
 *
 * @summary 条件式をTypeScriptの式に変換
 * @param condition - 条件式
 * @param states - 状態変数一覧
 * @returns TypeScript式
 */
function translateConditionToTypeScript(condition: string, states: SpecState[]): string {
  let result = condition
    // 複合演算子をプレースホルダーに置換
    .replace(/>=/g, "___GTE___")
    .replace(/<=/g, "___LTE___")
    .replace(/!=/g, "___NEQ___")
    .replace(/===/g, "___SEQ___")
    .replace(/==/g, "___EQ___")
    // 単一の=を===に変換
    .replace(/=/g, "===")
    // プレースホルダーを復元
    .replace(/___GTE___/g, ">=")
    .replace(/___LTE___/g, "<=")
    .replace(/___NEQ___/g, "!=")
    .replace(/___SEQ___/g, "===")
    .replace(/___EQ___/g, "===")
    // 論理演算子
    .replace(/\band\b/g, "&&")
    .replace(/\bor\b/g, "||")
    .replace(/\bnot\b/g, "!");

  // 状態変数をobj.field形式に変換（長い名前から先に処理）
  const sortedStates = [...states].sort((a, b) => b.name.length - a.name.length);
  for (const state of sortedStates) {
    const regex = new RegExp(`\\b${state.name}\\b`, "g");
    result = result.replace(regex, `obj.${state.name}`);
  }

  return result;
}

/**
 * Generate TypeScript validators from ParsedSpec
 *
 * @summary TypeScriptバリデーション関数を生成
 * @param spec - パース済み仕様
 * @param structName - 構造体名（省略時はタイトルから生成）
 * @returns 生成されたTypeScriptコード
 */
export function generateTsValidators(spec: ParsedSpec, structName?: string): GenerationOutput {
  const warnings: string[] = [];
  const errors: string[] = [];

  const name = structName || spec.title.replace(/[^a-zA-Z0-9]/g, "") || "Generated";

  let ts = `/**\n`;
  ts += ` * ${spec.title}のインバリアントバリデーション\n`;
  ts += ` * Generated by invariant-pipeline\n`;
  ts += ` */\n\n`;

  // インバリアント違反エラークラス
  ts += `/**\n`;
  ts += ` * インバリアント違反を表すエラー\n`;
  ts += ` */\n`;
  ts += `export class InvariantViolation extends Error {\n`;
  ts += `  constructor(\n`;
  ts += `    public readonly invariant: string,\n`;
  ts += `    public readonly details: string\n`;
  ts += `  ) {\n`;
  ts += `    super(\`Invariant '\${invariant}' violated: \${details}\`);\n`;
  ts += `    this.name = 'InvariantViolation';\n`;
  ts += `  }\n`;
  ts += `}\n\n`;

  // バリデーション結果型
  ts += `/**\n`;
  ts += ` * バリデーション結果\n`;
  ts += ` */\n`;
  ts += `export type ValidationResult<T> =\n`;
  ts += `  | { success: true; value: T }\n`;
  ts += `  | { success: false; violations: InvariantViolation[] };\n\n`;

  // モデルインターフェース
  ts += `/**\n`;
  ts += ` * ${name}モデルのインターフェース\n`;
  ts += ` */\n`;
  ts += `export interface ${name}Model {\n`;
  for (const s of spec.states) {
    ts += `  ${s.name}: ${mapTypeToTypeScript(s.type)};\n`;
  }
  ts += `}\n\n`;

  // バリデーション関数
  ts += `/**\n`;
  ts += ` * ${name}のインバリアントを検証する\n`;
  ts += ` * @param obj 検証対象のオブジェクト\n`;
  ts += ` * @returns バリデーション結果\n`;
  ts += ` */\n`;
  ts += `export function validate${name}Invariants(obj: ${name}Model): ValidationResult<${name}Model> {\n`;
  ts += `  const violations: InvariantViolation[] = [];\n\n`;

  for (const inv of spec.invariants) {
    ts += `  // ${inv.description || inv.name}\n`;
    ts += `  if (!(${translateConditionToTypeScript(inv.condition, spec.states)})) {\n`;
    ts += `    violations.push(new InvariantViolation(\n`;
    ts += `      '${inv.condition.replace(/'/g, "\\'")}',\n`;
    ts += `      \`Condition violated: ${inv.condition.replace(/`/g, '\\`')}\`\n`;
    ts += `    ));\n`;
    ts += `  }\n\n`;
  }

  ts += `  if (violations.length > 0) {\n`;
  ts += `    return { success: false, violations };\n`;
  ts += `  }\n`;
  ts += `  return { success: true, value: obj };\n`;
  ts += `}\n\n`;

  // 個別インバリアントチェック関数
  ts += `/**\n`;
  ts += ` * 個別のインバリアントチェッカー\n`;
  ts += ` */\n`;
  ts += `export const ${name}InvariantChecks = {\n`;
  for (const inv of spec.invariants) {
    const funcName = `check_${inv.name || `Invariant${spec.invariants.indexOf(inv) + 1}`}`;
    ts += `  ${funcName}: (obj: ${name}Model): boolean => {\n`;
    ts += `    // ${inv.description || inv.name}\n`;
    ts += `    return ${translateConditionToTypeScript(inv.condition, spec.states)};\n`;
    ts += `  },\n`;
  }
  ts += `};\n\n`;

  // 使用例
  ts += `// 使用例:\n`;
  ts += `// const model: ${name}Model = {\n`;
  for (const s of spec.states) {
    ts += `//   ${s.name}: ${getTypeScriptDefaultValue(s.type)},\n`;
  }
  ts += `// };\n`;
  ts += `// const result = validate${name}Invariants(model);\n`;
  ts += `// if (result.success) {\n`;
  ts += `//   console.log('Valid:', result.value);\n`;
  ts += `// } else {\n`;
  ts += `//   console.error('Violations:', result.violations);\n`;
  ts += `// }\n`;

  return { content: ts, warnings, errors };
}
