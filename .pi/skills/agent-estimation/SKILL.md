---
name: agent-estimation
description: AIエージェントの作業工数を、人間の時間ではなくエージェント自身の操作単位（ツール呼び出しラウンド）で正確に見積もる。見積もり、スコープ設定、計画、タスク所要時間の評価時に使用。エージェントが人間の開発者のタイムラインにアンカーして過大評価する失敗を防ぐ。ラウンド数、リスク要因、最終的な実時間変換を含む構造化された内訳を出力。
license: MIT
metadata:
  skill-version: "1.0.0"
  created-by: pi-skill-system
---

# エージェント作業見積もりスキル

## 問題

AIコーディングエージェントは、学習データから吸収した人間の開発者のタイムラインにアンカリング（固定）されるため、タスクの所要時間を体系的に過大評価する傾向がある。エージェントが30分で完了できるタスクが「2〜3日」と見積もられてしまう。これは人間の開発者向けのフォーラム投稿にそのように書かれているからである。

## 解決策

エージェント自身の操作単位である「ツール呼び出しラウンド（Round）」から見積もりを行い、最後の最後にのみ人間の実時間（wallclock time）に変換することを強制する。

## 使用タイミング

以下の場合にこのスキルを読み込む：
- タスクの所要時間を見積もる場合
- 作業計画を立てる場合
- 見積もりの妥当性を評価する場合

## 基本单位

| 単位 | 定義 | スケール |
|------|------|----------|
| **Round** | 1回のツール呼び出しサイクル：思考 → コード記述 → 実行 → 検証 → 修正 | 実時間で約2〜4分 |
| **Module** | 利用可能になるまで複数のRoundを経て構築される機能単位 | 2〜15 Round |
| **Project** | 全モジュール + 統合 + デバッグ | モジュール合計 × 統合係数 |

**Round**は原子単位である。以下の1回の反復に直接対応する：

1. エージェントが何をすべきか推論する
2. エージェントがコードを記述・編集する
3. エージェントがコードまたはテストを実行する
4. エージェントが出力を読み取る
5. エージェントが修正が必要か判断する（必要な場合 → 次のRound）

## 見積もり手順

タスクの見積もりを求められた場合、以下の手順を順番に実行する：

### 手順1: モジュールに分解

タスクを機能モジュールに分解する。各モジュールは独立して構築・テスト可能であるべき。自問する：「一度に1つずつ構築する個別の部品は何か？」

### 手順2: モジュールごとのRound見積もり

各モジュールについて、以下のアンカーを用いてRound数を見積もる：

| パターン | 典型的なRound数 | 例 |
|----------|-----------------|-----|
| **ボイラープレート / 既知のパターン** | 1〜2 | CRUDエンドポイント、設定ファイル、標準APIクライアント |
| **中程度の複雑さ** | 3〜5 | カスタムUIレイアウト、状態管理、データパイプライン |
| **探索的 / ドキュメント不足** | 5〜10 | 不慣れなフレームワーク、プラットフォーム固有API、複雑な統合 |
| **不確実性が高い** | 8〜15 | ドキュメント化されていない動作、新しいアルゴリズム、マルチシステムデバッグ |

重要なキャリブレーションルール：
- 1回のコード生成で動作する可能性が高い場合 → **1 Round**
- 生成、実行、エラー確認、修正が必要な場合 → **2〜3 Round**
- ライブラリ/フレームワークのドキュメントが少なく、推測が必要な場合 → **5+ Round**
- プラットフォームの権限、OSレベルAPI、環境固有の動作が関与し、ユーザーが手動で検証する必要がある場合 → **2〜3 Round追加**

### 手順3: リスク係数の割り当て

各モジュールにリスク係数を割り当て、Round数を増加させる：

| リスクレベル | 係数 | 適用タイミング |
|--------------|------|----------------|
| **低** | 1.0 | 成熟したエコシステム、明確なドキュメント、エージェントが強いパターンマッチを持つ |
| **中** | 1.3 | 軽微な未知要素、1〜2回の追加デバッグRoundが必要な可能性 |
| **高** | 1.5 | ドキュメントが少ない、プラットフォームの癖、統合の未知要素 |
| **非常に高い** | 2.0 | 行き止まりの可能性、アプローチ全体を変更する必要がある可能性 |

### 手順4: 合計の計算

```
モジュール実効Round数 = 基本Round数 × リスク係数
プロジェクトRound数 = Σ(モジュール実効Round数) + 統合Round数
統合Round数 = 基本合計の10〜20%（モジュールを接続するため）
```

### 手順5: 実時間への変換

最後の最後にのみ、人間の時間に変換する：

```
実時間 = プロジェクトRound数 × 1Roundあたりの分数
```

デフォルトの`1Roundあたりの分数` = **3分**（エージェント生成時間 + ユーザーレビュー時間を含む）。

コンテキストに応じてこのパラメータを調整する：
- 高速な反復、ユーザーがほとんどレビューしない → 2分/Round
- 複雑なドメイン、ユーザーが各ステップを注意深くレビュー → 4分/Round
- ユーザーが手動テストが必要（モバイル、ハードウェア、権限） → 5分/Round

## 出力フォーマット

常に以下の正確な構造で見積もりを出力する：

```markdown
### タスク: [タスク名]

#### モジュール分解

| # | モジュール | 基本Round数 | リスク | 実効Round数 | 備考 |
|---|-----------|-------------|--------|-------------|------|
| 1 | ...       | N           | 1.x    | M           | 理由 |
| 2 | ...       | N           | 1.x    | M           | 理由 |

#### サマリー

- **基本Round数**: X
- **統合**: +Y Round
- **リスク調整後合計**: Z Round
- **見積もり実時間**: A 〜 B 分（N分/Round）

#### 最大のリスク
1. [具体的なリスクと見積もりを膨らませる要因]
2. [...]
```

## 避けるべきアンチパターン

このスキルが防ぐために存在する失敗モード：

1. **人間の時間へのアンカリング**: 「開発者なら約2週間かかる...」 → 駄目。Roundから始めること。
2. **感覚的なパディング**: 具体的なリスク根拠なしに「念のため」時間を追加 → 駄目。リスク係数を使用すること。
3. **複雑さと量の混同**: 500行のボイラープレート ≠ 難しい。1行のCGEvent API ≠ 簡単。行数ではなく不確実性で見積もること。
4. **統合コストの忘却**: モジュールは単独で動作しても組み合わせると壊れる。常に統合Roundを追加すること。
5. **ユーザー側のボトルネックの無視**: ユーザーが手動で権限を付与、アプリを再起動、デバイスでテストする必要がある場合、それは追加のRound時間である。ファントムRoundを追加せず、`1Roundあたりの分数`を調整すること。
