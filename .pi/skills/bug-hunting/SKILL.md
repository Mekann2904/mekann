---
name: bug-hunting
description: バグ発見と根本原因特定のための体系的スキル。症状と原因の区別、因果チェーン分析、抽象化レベルの階層化を通じて、真の原因を見逃さないための手法論を提供。「第2理由問題」や「近接性バイアス」などの認知バイアスを回避し、機械的な探索プロセスを強制する。
license: MIT
tags: [debugging, root-cause-analysis, cognitive-bias, causal-chain, bug-hunting]
metadata:
  skill-version: "1.0.0"
  created-by: self-improvement-loop
  theoretical-foundation: "Five Whys, Ishikawa Diagram, Swiss Cheese Model, Cognitive Bias Research"
---

# Bug Hunting（バグハンティング）

バグ発見と根本原因特定のための体系的スキル。症状を直すのではなく、因果チェーン全体を可視化し、真の原因を見逃さないための手法論を提供する。

**核心原則:** 「症状は原因の影に過ぎない。影を追うな、本体を追え。」

**鉄の掟:**
```
最初の「なぜ」で止まるな
「発現点」≠「起源点」であることを前提とせよ
```

---

## なぜバグ発見は難しいのか

### 3つの認知バイアス

| バイアス | 説明 | 例 |
|---------|------|-----|
| **近接性バイアス** | 症状が現れる場所（発現点）で原因を探す | 型エラーの場所で修正するが、実際は設計の問題 |
| **具体性バイアス** | 具体的な症状に引きずられ、抽象的な原因を見逃す | null参照を修正するが、契約の不明確さが真の原因 |
| **完了への渇愛** | 最初の「説明」で探索を止める | 「変数がnullだった」で止まり、「なぜnullだったか」を問わない |

### 第2理由問題

「なぜ」を繰り返す手法（5 Whys）は有名だが、実践では最初の「なぜ」で止まることが多い。

```
観察: 型エラーが発生した
  ↓ なぜ？
第1理由: 変数xがundefinedだった      ← 多くはここで止まる
  ↓ なぜ？
第2理由: APIからデータが返されなかった
  ↓ なぜ？
第3理由: 認証トークンが期限切れだった
  ↓ なぜ？
第4理由: トークン更新処理が実装されていなかった  ← 真の原因
  ↓ なぜ？
第5理由: 要件に含まれていなかった           ← 根本原因
```

---

## 因果チェーン分析フレームワーク

### 基本概念

```
┌─────────────────────────────────────────────────────────────┐
│                    因果チェーンの構造                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  抽象化レベル                                                │
│  ─────────────────────────────────────────────────────────  │
│    │                                                        │
│    │  [意図]     「何を達成すべきか」                         │
│    │      │                                                 │
│    │      ▼                                                 │
│    │  [契約]     「何を約束するか」                           │
│    │      │                                                 │
│    │      ▼                                                 │
│    │  [設計]     「どう構成するか」                           │
│    │      │                                                 │
│    │      ▼                                                 │
│    │  [実装]     「どう記述するか」                           │
│    │      │                                                 │
│    │      ▼                                                 │
│    │  [実行]     「どう動くか」                               │
│    │                                                        │
│  ─────────────────────────────────────────────────────────  │
│                                                             │
│  起源点（上層）←──────────────→ 発現点（下層）                │
│     真の原因                      症状                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 5つの抽象化レベル

| レベル | 問い | 典型的な問題 |
|--------|------|------------|
| **意図 (Intent)** | 「何を達成すべきか？」 | 要件の欠落、誤解、矛盾 |
| **契約 (Contract)** | 「何を約束するか？」 | インターフェースの不明確さ、前提の暗黙化 |
| **設計 (Design)** | 「どう構成するか？」 | 責任の混乱、依存関係の問題、不適切な抽象化 |
| **実装 (Implementation)** | 「どう記述するか？」 | ロジックエラー、型ミス、境界条件 |
| **実行 (Execution)** | 「どう動くか？」 | 実行時エラー、パフォーマンス問題、リソース不足 |

---

## 機械的探索プロセス

### Phase 1: 発現点の特定

**症状を正確に記述する:**

```markdown
## 症状記述テンプレート

### What（何が起きたか）
- 現象: [具体的なエラー/挙動]
- 場所: [ファイル:行番号]
- タイミング: [いつ発生するか]

### Context（文脈）
- 前提条件: [何が成立している必要があるか]
- 再現手順: [どうすれば再現できるか]
- 影響範囲: [何に影響するか]

### Not（何でないか）
- 関連しない要素: [除外できること]
- 以前の仮説: [すでに検証済みで否定されたこと]
```

### Phase 2: 因果チェーンの構築

**「なぜ」を各抽象化レベルで繰り返す:**

```markdown
## 因果チェーン分析テンプレート

### 実行レベル
- 現象: [症状]
- なぜ？: [直接的な原因]
- 証拠: [どうやって確認したか]

### 実装レベル
- なぜ？: [実装上の原因]
- 証拠: [コード/ログ]

### 設計レベル
- なぜ？: [設計上の原因]
- 証拠: [設計書/依存関係]

### 契約レベル
- なぜ？: [契約上の問題]
- 証拠: [インターフェース/ドキュメント]

### 意図レベル
- なぜ？: [意図/要件の問題]
- 証拠: [要件定義/ユーザー期待]
```

### Phase 3: 停止条件の確認

**探索を止めてよいかのチェックリスト:**

```markdown
## 探索停止チェック

[ ] 因果チェーンが「意図」レベルまで到達した
[ ] 各レベルで「なぜ」に答えている
[ ] 代替仮説を検討し、排除した
[ ] 修正案が再発防止につながる（対症療法でない）
[ ] 同様の問題が他の場所にもないか確認した

※ 上記のいずれかが「いいえ」の場合、探索を続ける
```

---

## 探索的質問セット

### 症状レベルの質問

```
Q1: この症状は「必ず」発生するか、それとも「条件次第」か？
Q2: この症状は「いつから」発生し始めたか？
Q3: この症状は「どこで」発生し、「どこでは発生しない」か？
Q4: 同じような症状が他の場所にもないか？
```

### 原因レベルの質問

```
Q5: この説明は「なぜ」成立するのか？（さらに深掘り）
Q6: この説明が正しいとすると、他に「何が予測できる」か？
Q7: この説明と「矛盾する」証拠はないか？
Q8: 「別の説明」で同じ症状を説明できるか？
```

### 修正レベルの質問

```
Q9: この修正は「再発を防ぐ」か、それとも「今回の症状を消すだけ」か？
Q10: この修正は「他に影響を与えない」か？
Q11: 同じ原因による「他の症状」はないか？
Q12: この問題が「なぜ今まで発見されなかった」のか？
```

---

## よくある症状-原因マッピング

### 実行レベルの症状

| 症状 | 第1レベル原因 | より深い原因 |
|------|--------------|-------------|
| TypeError | 型不一致 | 契約の不明確さ、型設計の不備 |
| null/undefined | 値の欠落 | 初期化フローの問題、オプショナルの誤用 |
| 例外/クラッシュ | エッジケース未処理 | 入力検証の欠如、契約違反の検出不足 |
| パフォーマンス低下 | 非効率な処理 | アルゴリズム選択の誤り、データ構造の不適切さ |

### 実装レベルの症状

| 症状 | 第1レベル原因 | より深い原因 |
|------|--------------|-------------|
| ロジックエラー | 条件分岐ミス | 状態設計の問題、ドメイン理解不足 |
| メモリリーク | 解放忘れ | ライフサイクル管理の欠如、所有権の不明確さ |
| 競合状態 | 同期不足 | 並行性設計の問題、共有状態の誤り |

### 設計レベルの症状

| 症状 | 第1レベル原因 | より深い原因 |
|------|--------------|-------------|
| 循環依存 | 構造の問題 | 責任分離の失敗、モジュール境界の不明確さ |
| 変更の波及 | 結合度過多 | 抽象化の不備、インターフェース設計の問題 |
| テスト困難 | 依存の複雑さ | DIの欠如、副作用の隠蔽 |

---

## Inspector/Challengerパターンとの統合

### Bug Hunting Inspector

**因果チェーンの完全性を監査する:**

```markdown
## Inspector チェックリスト

### 因果チェーンの完全性
- [ ] 因果チェーンが5つのレベルすべてをカバーしているか
- [ ] 各レベルで「なぜ」に答えているか
- [ ] 「なぜ」の答えが証拠で裏付けられているか

### 探索の十分性
- [ ] 代替仮説を検討したか
- [ ] 矛盾する証拠を探したか
- [ ] 境界条件を確認したか

### 修正の適切性
- [ ] 修正が再発防止につながるか
- [ ] 修正が対症療法でないか
- [ ] 他の場所にも同じ問題がないか確認したか
```

### Bug Hunting Challenger

**原因特定の主張に挑戦する:**

```markdown
## Challenger テンプレート

CHALLENGED_CLAIM: 「このバグの原因は[原因]である」

EVIDENCE_GAP:
- [原因]を支持する証拠は何か
- [原因]を否定する証拠を探したか
- 因果関係は相関関係でないか

ALTERNATIVE_EXPLANATIONS:
- 他に考えられる原因は何か
- 同じ症状を生む別のメカニズムはないか

BOUNDARY_FAILURE:
- [原因]という説明が成立しない条件は何か
- 例外ケースは何か

SEVERITY: minor | moderate | critical
```

---

## 実践例

### 例1: TypeError: Cannot read property 'x' of undefined

```markdown
## 症状
- 現象: TypeError: Cannot read property 'x' of undefined
- 場所: user.service.ts:45
- タイミング: ユーザー登録後の画面遷移時

## 因果チェーン

### 実行レベル
- なぜ？: userオブジェクトがundefinedだった
- 証拠: コンソールログで確認

### 実装レベル
- なぜ？: API呼び出しの戻り値が期待と異なっていた
- 証拠: ネットワークタブで確認（空オブジェクトが返ってきた）

### 設計レベル
- なぜ？: APIが404の場合に空オブジェクトを返す設計だった
- 証拠: API設計書

### 契約レベル
- なぜ？: 「ユーザーが存在しない場合」の契約が不明確だった
- 証拠: インターフェース定義にJSDocがない

### 意図レベル
- なぜ？: 「ユーザー登録後に即座にユーザー情報を取得する」という要件が非同期処理を考慮していなかった
- 証拠: 要件定義書

## 根本原因
要件レベルで「登録完了のタイミング」が明確でなく、バックエンドとフロントエンドで前提が異なっていた。

## 再発防止策
1. [契約] APIの契約を明確化（404の場合はnullを返す）
2. [設計] フロントエンドでnullチェックを追加
3. [意図] 「登録完了」の定義を明確化
```

### 例2: テストが時々失敗する

```markdown
## 症状
- 現象: テストが時々失敗する（フレーキー）
- 場所: integration.test.ts
- タイミング: CI環境で約30%の確率で失敗

## 因果チェーン

### 実行レベル
- なぜ？: テスト実行時にデータベースの状態が期待と異なる
- 証拠: テストログで確認

### 実装レベル
- なぜ？: テスト間でデータベースのクリーンアップが不完全
- 証拠: テストコード確認（afterEachで全テーブルをクリアしていない）

### 設計レベル
- なぜ？: テストの並列実行を考慮した設計になっていない
- 証拠: テスト設定ファイル（parallel: true）

### 契約レベル
- なぜ？: テストの独立性情報が定義されていない
- 証拠: テストのベストプラクティス文書がない

### 意図レベル
- なぜ？: 「テストは高速であるべき」という要件が「並列実行」を前提としていなかった
- 証拠: パフォーマンス要件

## 根本原因
テスト設計段階で「テストの独立性」と「並列実行」の関係が考慮されていなかった。

## 再発防止策
1. [実装] afterEachで確実にクリーンアップ
2. [設計] テストデータの分離戦略を策定
3. [契約] テスト独立性のガイドライン策定
```

---

## チェックリスト

### バグ発見時

```
[ ] 症状を正確に記述したか
[ ] 因果チェーンを5つのレベルで構築したか
[ ] 各レベルで証拠を収集したか
[ ] 代替仮説を検討したか
[ ] 修正が再発防止につながるか
```

### コードレビュー時

```
[ ] バグ修正が対症療法でないか確認したか
[ ] 同じ原因による他の問題がないか確認したか
[ ] 因果チェーンが十分に深く掘り下げられているか
```

---

## 関連スキル

- `verification-workflow` - Inspector/Challengerパターンによる出力検証
- `harness-engineering` - 品質と信頼性を高める手法論
- `test-engineering` - 包括的テスト戦略
- `invariant-generation` - 形式仕様からインバリアント生成

---

## デバッグ情報

### 記録されるイベント

このスキルの実行時に記録されるイベント：

| イベント種別 | 説明 | 記録タイミング |
|-------------|------|---------------|
| bug_hunt_start | バグハンティング開始 | 症状報告時 |
| causal_chain_built | 因果チェーン構築完了 | 分析完了時 |
| root_cause_identified | 根本原因特定 | 原因特定時 |
| fix_applied | 修正適用 | 修正完了時 |

### ログ確認方法

```bash
# バグハンティング関連のログを確認
cat .pi/logs/events-*.jsonl | jq 'select(.eventType | contains("bug"))'

# 根本原因特定のログを確認
cat .pi/logs/events-*.jsonl | jq 'select(.eventType == "root_cause_identified")'
```

### トラブルシューティング

| 症状 | 考えられる原因 | 確認方法 | 解決策 |
|------|---------------|---------|--------|
| 原因が特定できない | 情報不足 | ログ/再現手順を確認 | 観察ポイントを増やす |
| 複数の原因候補がある | 因果関係の誤認 | 代替仮説を検証 | 実験で絞り込む |
| 修正しても再発する | 根本原因でない | 因果チェーンを見直す | より深いレベルを探索 |

### 関連ファイル

- 実装: `.pi/extensions/verification-workflow.ts`
- ログ: `.pi/logs/events-YYYY-MM-DD.jsonl`
