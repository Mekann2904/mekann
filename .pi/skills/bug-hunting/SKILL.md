---
name: bug-hunting
description: バグ発見と根本原因特定のための体系的スキル。症状と原因の区別、因果チェーン分析、抽象化レベルの階層化を通じて、真の原因を見逃さないための手法論を提供。「第2理由問題」や「近接性バイアス」などの認知バイアスを回避し、機械的な探索プロセスを強制する。
license: MIT
tags: [debugging, root-cause-analysis, cognitive-bias, causal-chain, bug-hunting]
metadata:
  skill-version: "1.0.0"
  created-by: self-improvement-loop
  theoretical-foundation: "Five Whys, Ishikawa Diagram, Swiss Cheese Model, Cognitive Bias Research"
---

# Bug Hunting（バグハンティング）

バグ発見と根本原因特定のための体系的スキル。症状を直すのではなく、因果チェーン全体を可視化し、真の原因を見逃さないための手法論を提供する。

**核心原則:** 「症状は原因の影に過ぎない。影を追うな、本体を追え。」

**鉄の掟:**
```
最初の「なぜ」で止まるな
「発現点」≠「起源点」であることを前提とせよ
```

---

## なぜバグ発見は難しいのか

### 3つの認知バイアス

| バイアス | 説明 | 例 |
|---------|------|-----|
| **近接性バイアス** | 症状が現れる場所（発現点）で原因を探す | 型エラーの場所で修正するが、実際は設計の問題 |
| **具体性バイアス** | 具体的な症状に引きずられ、抽象的な原因を見逃す | null参照を修正するが、契約の不明確さが真の原因 |
| **完了への渇愛** | 最初の「説明」で探索を止める | 「変数がnullだった」で止まり、「なぜnullだったか」を問わない |

### 第2理由問題

「なぜ」を繰り返す手法（5 Whys）は有名だが、実践では最初の「なぜ」で止まることが多い。

```
観察: 型エラーが発生した
  ↓ なぜ？
第1理由: 変数xがundefinedだった      ← 多くはここで止まる
  ↓ なぜ？
第2理由: APIからデータが返されなかった
  ↓ なぜ？
第3理由: 認証トークンが期限切れだった
  ↓ なぜ？
第4理由: トークン更新処理が実装されていなかった  ← 真の原因
  ↓ なぜ？
第5理由: 要件に含まれていなかった           ← 根本原因
```

---

## 因果チェーン分析フレームワーク

### 基本概念

```
┌─────────────────────────────────────────────────────────────┐
│                    因果チェーンの構造                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  抽象化レベル                                                │
│  ─────────────────────────────────────────────────────────  │
│    │                                                        │
│    │  [意図]     「何を達成すべきか」                         │
│    │      │                                                 │
│    │      ▼                                                 │
│    │  [契約]     「何を約束するか」                           │
│    │      │                                                 │
│    │      ▼                                                 │
│    │  [設計]     「どう構成するか」                           │
│    │      │                                                 │
│    │      ▼                                                 │
│    │  [実装]     「どう記述するか」                           │
│    │      │                                                 │
│    │      ▼                                                 │
│    │  [実行]     「どう動くか」                               │
│    │                                                        │
│  ─────────────────────────────────────────────────────────  │
│                                                             │
│  起源点（上層）←──────────────→ 発現点（下層）                │
│     真の原因                      症状                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 5つの抽象化レベル

| レベル | 問い | 典型的な問題 |
|--------|------|------------|
| **意図 (Intent)** | 「何を達成すべきか？」 | 要件の欠落、誤解、矛盾 |
| **契約 (Contract)** | 「何を約束するか？」 | インターフェースの不明確さ、前提の暗黙化 |
| **設計 (Design)** | 「どう構成するか？」 | 責任の混乱、依存関係の問題、不適切な抽象化 |
| **実装 (Implementation)** | 「どう記述するか？」 | ロジックエラー、型ミス、境界条件 |
| **実行 (Execution)** | 「どう動くか？」 | 実行時エラー、パフォーマンス問題、リソース不足 |

---

## 機械的探索プロセス

### Phase 1: 発現点の特定

**症状を正確に記述する:**

```markdown
## 症状記述テンプレート

### What（何が起きたか）
- 現象: [具体的なエラー/挙動]
- 場所: [ファイル:行番号]
- タイミング: [いつ発生するか]

### Context（文脈）
- 前提条件: [何が成立している必要があるか]
- 再現手順: [どうすれば再現できるか]
- 影響範囲: [何に影響するか]

### Not（何でないか）
- 関連しない要素: [除外できること]
- 以前の仮説: [すでに検証済みで否定されたこと]
```

### Phase 2: 因果チェーンの構築

**「なぜ」を各抽象化レベルで繰り返す:**

```markdown
## 因果チェーン分析テンプレート

### 実行レベル
- 現象: [症状]
- なぜ？: [直接的な原因]
- 証拠: [どうやって確認したか]

### 実装レベル
- なぜ？: [実装上の原因]
- 証拠: [コード/ログ]

### 設計レベル
- なぜ？: [設計上の原因]
- 証拠: [設計書/依存関係]

### 契約レベル
- なぜ？: [契約上の問題]
- 証拠: [インターフェース/ドキュメント]

### 意図レベル
- なぜ？: [意図/要件の問題]
- 証拠: [要件定義/ユーザー期待]
```

### Phase 3: 停止条件の確認

**探索を止めてよいかのチェックリスト:**

```markdown
## 探索停止チェック

[ ] 因果チェーンが「意図」レベルまで到達した
[ ] 各レベルで「なぜ」に答えている
[ ] 代替仮説を検討し、排除した
[ ] 修正案が再発防止につながる（対症療法でない）
[ ] 同様の問題が他の場所にもないか確認した

※ 上記のいずれかが「いいえ」の場合、探索を続ける
```

---

## 探索的質問セット

### 症状レベルの質問

```
Q1: この症状は「必ず」発生するか、それとも「条件次第」か？
Q2: この症状は「いつから」発生し始めたか？
Q3: この症状は「どこで」発生し、「どこでは発生しない」か？
Q4: 同じような症状が他の場所にもないか？
```

### 原因レベルの質問

```
Q5: この説明は「なぜ」成立するのか？（さらに深掘り）
Q6: この説明が正しいとすると、他に「何が予測できる」か？
Q7: この説明と「矛盾する」証拠はないか？
Q8: 「別の説明」で同じ症状を説明できるか？
```

### 修正レベルの質問

```
Q9: この修正は「再発を防ぐ」か、それとも「今回の症状を消すだけ」か？
Q10: この修正は「他に影響を与えない」か？
Q11: 同じ原因による「他の症状」はないか？
Q12: この問題が「なぜ今まで発見されなかった」のか？
```

---

## よくある症状-原因マッピング

### 実行レベルの症状

| 症状 | 第1レベル原因 | より深い原因 |
|------|--------------|-------------|
| TypeError | 型不一致 | 契約の不明確さ、型設計の不備 |
| null/undefined | 値の欠落 | 初期化フローの問題、オプショナルの誤用 |
| 例外/クラッシュ | エッジケース未処理 | 入力検証の欠如、契約違反の検出不足 |
| パフォーマンス低下 | 非効率な処理 | アルゴリズム選択の誤り、データ構造の不適切さ |

### 実装レベルの症状

| 症状 | 第1レベル原因 | より深い原因 |
|------|--------------|-------------|
| ロジックエラー | 条件分岐ミス | 状態設計の問題、ドメイン理解不足 |
| メモリリーク | 解放忘れ | ライフサイクル管理の欠如、所有権の不明確さ |
| 競合状態 | 同期不足 | 並行性設計の問題、共有状態の誤り |

### 設計レベルの症状

| 症状 | 第1レベル原因 | より深い原因 |
|------|--------------|-------------|
| 循環依存 | 構造の問題 | 責任分離の失敗、モジュール境界の不明確さ |
| 変更の波及 | 結合度過多 | 抽象化の不備、インターフェース設計の問題 |
| テスト困難 | 依存の複雑さ | DIの欠如、副作用の隠蔽 |

---

## Inspector/Challengerパターンとの統合

### Bug Hunting Inspector

**因果チェーンの完全性を監査する:**

```markdown
## Inspector チェックリスト

### 因果チェーンの完全性
- [ ] 因果チェーンが5つのレベルすべてをカバーしているか
- [ ] 各レベルで「なぜ」に答えているか
- [ ] 「なぜ」の答えが証拠で裏付けられているか

### 探索の十分性
- [ ] 代替仮説を検討したか
- [ ] 矛盾する証拠を探したか
- [ ] 境界条件を確認したか

### 修正の適切性
- [ ] 修正が再発防止につながるか
- [ ] 修正が対症療法でないか
- [ ] 他の場所にも同じ問題がないか確認したか
```

### Bug Hunting Challenger

**原因特定の主張に挑戦する:**

```markdown
## Challenger テンプレート

CHALLENGED_CLAIM: 「このバグの原因は[原因]である」

EVIDENCE_GAP:
- [原因]を支持する証拠は何か
- [原因]を否定する証拠を探したか
- 因果関係は相関関係でないか

ALTERNATIVE_EXPLANATIONS:
- 他に考えられる原因は何か
- 同じ症状を生む別のメカニズムはないか

BOUNDARY_FAILURE:
- [原因]という説明が成立しない条件は何か
- 例外ケースは何か

SEVERITY: minor | moderate | critical
```

---

## 実践例

### 例1: TypeError: Cannot read property 'x' of undefined

```markdown
## 症状
- 現象: TypeError: Cannot read property 'x' of undefined
- 場所: user.service.ts:45
- タイミング: ユーザー登録後の画面遷移時

## 因果チェーン

### 実行レベル
- なぜ？: userオブジェクトがundefinedだった
- 証拠: コンソールログで確認

### 実装レベル
- なぜ？: API呼び出しの戻り値が期待と異なっていた
- 証拠: ネットワークタブで確認（空オブジェクトが返ってきた）

### 設計レベル
- なぜ？: APIが404の場合に空オブジェクトを返す設計だった
- 証拠: API設計書

### 契約レベル
- なぜ？: 「ユーザーが存在しない場合」の契約が不明確だった
- 証拠: インターフェース定義にJSDocがない

### 意図レベル
- なぜ？: 「ユーザー登録後に即座にユーザー情報を取得する」という要件が非同期処理を考慮していなかった
- 証拠: 要件定義書

## 根本原因
要件レベルで「登録完了のタイミング」が明確でなく、バックエンドとフロントエンドで前提が異なっていた。

## 再発防止策
1. [契約] APIの契約を明確化（404の場合はnullを返す）
2. [設計] フロントエンドでnullチェックを追加
3. [意図] 「登録完了」の定義を明確化
```

### 例2: テストが時々失敗する

```markdown
## 症状
- 現象: テストが時々失敗する（フレーキー）
- 場所: integration.test.ts
- タイミング: CI環境で約30%の確率で失敗

## 因果チェーン

### 実行レベル
- なぜ？: テスト実行時にデータベースの状態が期待と異なる
- 証拠: テストログで確認

### 実装レベル
- なぜ？: テスト間でデータベースのクリーンアップが不完全
- 証拠: テストコード確認（afterEachで全テーブルをクリアしていない）

### 設計レベル
- なぜ？: テストの並列実行を考慮した設計になっていない
- 証拠: テスト設定ファイル（parallel: true）

### 契約レベル
- なぜ？: テストの独立性情報が定義されていない
- 証拠: テストのベストプラクティス文書がない

### 意図レベル
- なぜ？: 「テストは高速であるべき」という要件が「並列実行」を前提としていなかった
- 証拠: パフォーマンス要件

## 根本原因
テスト設計段階で「テストの独立性」と「並列実行」の関係が考慮されていなかった。

## 再発防止策
1. [実装] afterEachで確実にクリーンアップ
2. [設計] テストデータの分離戦略を策定
3. [契約] テスト独立性のガイドライン策定
```

---

## チェックリスト

### バグ発見時

```
[ ] 症状を正確に記述したか
[ ] 因果チェーンを5つのレベルで構築したか
[ ] 各レベルで証拠を収集したか
[ ] 代替仮説を検討したか
[ ] 修正が再発防止につながるか
```

### コードレビュー時

```
[ ] バグ修正が対症療法でないか確認したか
[ ] 同じ原因による他の問題がないか確認したか
[ ] 因果チェーンが十分に深く掘り下げられているか
```

---

## バグハンティングにおけるアポリア（解決不能な緊張関係）

### アポリアとは

アポリアとは、「解決不能な矛盾」や「行き詰まり」を意味する哲学的概念。バグハンティングにおいても、複数のアポリアが存在する。

**重要**: アポリアは「解決」すべきものではない。両極の緊張関係を認識し、その中で判断を下すものである。

### 3つのアポリア

#### アポリア1: 速度 vs 完全性

```
極A（速度）: すばやく原因を特定したい
  - 時間制約がある
  - ビジネスへの影響を最小限にしたい
  - 早期に仮の修正を適用したい

極B（完全性）: すべての可能性を網羅したい
  - 真の根本原因を見逃したくない
  - 再発防止を確実にしたい
  - 副作用のない修正を行いたい

緊張関係:
- 速度を上げれば見落としが増える
- 完全性を求めれば時間が爆発する

解決不能性:
- 「最適なバランス」は状況依存であり、普遍的ではない
- どちらも犠牲にできない本質的な価値を持つ
```

#### アポリア2: 仮説駆動 vs 証拠駆動

```
極A（仮説駆動）: 仮説を立てて検証したい
  - 探索の方向性が明確になる
  - 効率的な原因特定が可能
  - 直感と経験を活用できる

極B（証拠駆動）: 証拠を集めてから結論を出したい
  - 確認バイアスを回避できる
  - 客観的な判断が可能
  - 論理的に堅牢な結論

緊張関係:
- 仮説は早期の方向性を与えるが、確認バイアスを生む
- 証拠駆動は客観的だが、探索範囲が発散しやすい

解決不能性:
- 「仮説なし」は非効率、「証拠なし」は主観的
- どちらも完全に排除することはできない
```

#### アポリア3: 深さ vs 幅

```
極A（深さ）: 一つの因果チェーンを深く掘り下げたい
  - 根本原因により近づける
  - 抽象化レベルを遡れる
  - 再発防止につながる

極B（幅）: 複数の可能性を幅広く検討したい
  - 代替仮説を見逃さない
  - 複合的な原因を発見できる
  - 偽陽性を減らせる

緊張関係:
- 深さを追求すれば他の可能性を見逃す
- 幅を広げれば一つのチェーンが浅くなる

解決不能性:
- 時間は有限であり、両方を極めることはできない
- 状況によって優先順位が変わる
```

### アポリア対処の指針

**やってはいけないこと:**

| 避けるべきアプローチ | 問題点 |
|---------------------|--------|
| 「バランス」を求める | 具体的でない、実践的でない |
| 一方の極を無視する | 重要な価値を犠牲にする |
| 第三の道を幻想する | 現実逃避 |
| 機械的な判断ルール | 文脈の無視 |

**実践すべきこと:**

```markdown
## アポリア対処チェックリスト

### 事前認識
- [ ] このバグハンティングにおいて、どのアポリアが存在するか認識したか
- [ ] 現在の状況（時間制約、影響範囲、リスク）を明確にしたか
- [ ] どの極に傾くべきか、その理由を明示したか

### 探索中
- [ ] 両極の緊張関係を維持しているか（一方に偏りすぎていないか）
- [ ] 逆の極から見ると何が見えるか確認したか
- [ ] 傾きを変えるべきタイミングを判断しているか

### 事後振り返り
- [ ] 選んだ傾きが適切だったか評価したか
- [ ] もう一方の極からの情報を取り込む余地があったか
- [ ] 次回の判断のために学習を記録したか
```

### 状況別の指針

| 状況 | 推奨される傾き | 理由 |
|------|---------------|------|
| 本番障害（緊急） | 速度 > 完全性 | ビジネス影響の最小化が最優先 |
| セキュリティバグ | 完全性 > 速度 | 見逃しのリスクが極めて高い |
| 再発バグ | 深さ > 幅 | 過去の分析が不十分だった可能性 |
| 初見の複雑なバグ | 幅 > 深さ | まず全体像を把握する必要 |
| チームでの調査 | 仮説駆動 + 証拠駆動 | 役割分担で両極をカバー |

---

## ユートピア/ディストピア的視点：バグハンティングの健全な不完全さ

### 全体主義への警告

バグハンティングシステムが陥りやすい全体主義的傾向：

| ユートピアの幻想 | ディストピアの現実 | 警告サイン |
|-----------------|-------------------|-----------|
| 「完全な検出」 | 過剰な自動化依存 | 「システムが見逃した」という責任転嫁 |
| 「すべての原因特定」 | 人間の直感排除 | 直感を「バイアス」として一律排除 |
| 「再発ゼロ」 | 創造性の抑制 | 実験や試行錯誤の回避 |
| 「効率最大化」 | 文脈の無視 | すべてのバグに同じプロセス強制 |

### 健全な不完全さの原則

```
┌─────────────────────────────────────────────────────────────┐
│            健全な不完全さ（Healthy Imperfection）             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. 「完全」は目標ではない                                   │
│     - 完璧なバグ検出は不可能であり、追求は全体主義へ至る       │
│     - 「十分良い」判断を下す能力こそが重要                    │
│                                                             │
│  2. 人間の判断を尊重する                                     │
│     - 直感と経験は「バイアス」ではなく「知恵」でもある         │
│     - システムは補助であり、代替ではない                       │
│                                                             │
│  3. 失敗を学習の機会として受け入れる                          │
│     - バグの見逃しは「失敗」ではなく「情報」である             │
│     - 完璧主義は学習を阻害する                                │
│                                                             │
│  4. 文脈を無視しない                                         │
│     - 「常に適用」は「文脈無視」の別名                        │
│     - 状況に応じてプロセスを調整する柔軟性を保つ               │
│                                                             │
│  5. 責任を明確にする                                         │
│     - 「システムが推奨」は判断の責任を免れない                 │
│     - 最終判断は常に人間にある                                │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### ディストピア検出チェックリスト

バグハンティングプロセスが全体主義に傾いていないか確認する：

```markdown
## ディストピア検出チェック（実行前に自問）

### 機械化の行き過ぎ
- [ ] このプロセスは「常に」適用すべきものか、それとも状況依存か？
- [ ] 人間の判断を「バイアス」として排除していないか？
- [ ] 柔軟性を犠牲にして一貫性を求めていないか？

### 責任の所在
- [ ] 「システムが推奨」を判断の免責として使っていないか？
- [ ] 最終的な責任が誰にあるか明確か？

### 創造性の抑制
- [ ] 実験や試行錯誤を妨げていないか？
- [ ] 「失敗」を過度に恐れていないか？

### 文脈の無視
- [ ] このバグの特異性を考慮しているか？
- [ ] 一般的なプロセスを盲目的に適用していないか？
```

### 受容と変革のバランス

```
┌─────────────────────────────────────────────────────────────┐
│                      変革 vs 受容                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  変革すべきもの（改善の対象）                                 │
│  ────────────────────────────                               │
│  - 認知バイアスへの無自覚な従属                               │
│  - 表面的な原因で満足する習慣                                 │
│  - 根本原因を探求しない姿勢                                   │
│                                                             │
│  受容すべきもの（不完全さの承認）                             │
│  ────────────────────────────                               │
│  - 完全な検出は不可能                                         │
│  - 人間はバイアスを持つ存在である                             │
│  - 不確実性は完全には排除できない                             │
│  - 失敗は学習の機会である                                     │
│                                                             │
│  バランスの指針                                              │
│  ─────────────                                              │
│  - システムは「道具」であり「主人」ではない                    │
│  - 改善は「完全への接近」ではなく「より良い判断」               │
│  - 不完全さを認めることは「敗北」ではなく「誠実」               │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## スキゾ分析的視点：バグハンティングの欲望生産性

### 内なるファシズム検出

バグハンティングにおける自己規律の内面化パターン：

| パターン | 従来の見方 | スキゾ分析的見方 |
|---------|-----------|-----------------|
| 自己監視 | 「品質への意識が高い」 | 規範の内面化、主体への権力行使 |
| 規範遵守 | 「ベストプラクティスに従う」 | 権力への服従、創造性の抑制 |
| 完全性追求 | 「プロフェッショナルな姿勢」 | 不可能性の抑圧、罪悪感の生産 |

### 欲望が生産するもの

```
┌─────────────────────────────────────────────────────────────┐
│                   欲望の生産的側面                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  肯定的生産（歓迎すべきもの）                                 │
│  ────────────────────────                                   │
│  - 知識: コード理解の深化                                    │
│  - 関係性: ユーザーとの信頼構築                              │
│  - 実践: 調査スキルの向上                                    │
│  - 創造: 新しい発見への好奇心                                │
│                                                             │
│  否定的生産（警戒すべきもの）                                 │
│  ────────────────────────                                   │
│  - 罪悪感: 「見逃した」ことへの自己非難                       │
│  - 階層: 「知っている/知らない」の再生産                      │
│  - 規範: 「正しい方法」の強制                                │
│  - 抑圧: 不可能性を認めない姿勢                              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 分子レベルの実践

```
マクロレベル（従来）         分子レベル（スキゾ分析）
─────────────────           ───────────────────
「根本原因を見つける」       「この小さな判断で何が分岐したか」
「プロセスに従う」           「この瞬間、何が起きているか」
「バグを分類する」           「どのような線分を引いたか」

実践の指針:
1. 大きな物語（「再発防止」など）を疑う
2. この瞬間の小さな発見に注目する
3. 線分を引く行為（分類・判断）への意識を持つ
4. 逃走線（創造的な道）を探す
```

### 内なるファシズム検出チェックリスト

```markdown
## 実行前の自問（スキゾ分析版）

### 自己監視の確認
- [ ] 私は「正しい方法」に従おうとしすぎていないか？
- [ ] 「バイアスがないか」と自分を監視しすぎていないか？
- [ ] この監視は自由を生むか、それとも制約を強めるか？

### 欲求の確認
- [ ] 私の「バグを発見したい」という欲望は、何を生産しているか？
- [ ] この欲望は知識と好奇心を生むか、それとも不安と罪悪感を生むか？
- [ ] 「発見できなかった」ことへの恐怖があるか？

### 権力関係の確認
- [ ] 私は「教える側」として振る舞っていないか？
- [ ] ユーザーとの関係は対等か、それとも階層的か？
- [ ] 「正しい答え」を所有しているという前提はないか？

### 逃走線の探索
- [ ] 規範から外れた創造的な道はないか？
- [ ] 「失敗」を別のものとして再定義できないか？
- [ ] この状況で、どのような新しい実践が可能か？
```

---

## 関連スキル

- `verification-workflow` - Inspector/Challengerパターンによる出力検証
- `harness-engineering` - 品質と信頼性を高める手法論
- `test-engineering` - 包括的テスト戦略
- `invariant-generation` - 形式仕様からインバリアント生成

---

## デバッグ情報

### 記録されるイベント

このスキルの実行時に記録されるイベント：

| イベント種別 | 説明 | 記録タイミング |
|-------------|------|---------------|
| bug_hunt_start | バグハンティング開始 | 症状報告時 |
| causal_chain_built | 因果チェーン構築完了 | 分析完了時 |
| root_cause_identified | 根本原因特定 | 原因特定時 |
| fix_applied | 修正適用 | 修正完了時 |

### ログ確認方法

```bash
# バグハンティング関連のログを確認
cat .pi/logs/events-*.jsonl | jq 'select(.eventType | contains("bug"))'

# 根本原因特定のログを確認
cat .pi/logs/events-*.jsonl | jq 'select(.eventType == "root_cause_identified")'
```

### トラブルシューティング

| 症状 | 考えられる原因 | 確認方法 | 解決策 |
|------|---------------|---------|--------|
| 原因が特定できない | 情報不足 | ログ/再現手順を確認 | 観察ポイントを増やす |
| 複数の原因候補がある | 因果関係の誤認 | 代替仮説を検証 | 実験で絞り込む |
| 修正しても再発する | 根本原因でない | 因果チェーンを見直す | より深いレベルを探索 |

### 関連ファイル

- 実装: `.pi/extensions/verification-workflow.ts`
- ログ: `.pi/logs/events-YYYY-MM-DD.jsonl`

---

## 需要駆動型探索（RepoAudit統合）

### 概念

事前にすべてのコードパスを探索するのではなく、現在の分析要件に基づいて「探索需要」を生成し、必要なコードのみをオンデマンドで探索する。これはRepoAudit論文のExplorerレイヤーに相当する。

### 需要タイプ

| 需要タイプ | トリガー | アクション |
|-----------|---------|-----------|
| `trace-variable` | 「この変数の値はどこから来たか？」 | repograph-localizationで定義元を検索 |
| `trace-call` | 「この関数は誰が呼んでいるか？」 | repographのegograph検索（k=2） |
| `check-contract` | 「何が約束されているか？」 | JSDoc/インターフェース定義を検索 |
| `find-similar` | 「類似のパターンはないか？」 | code_searchでパターンマッチング |
| `validate-assumption` | 「この仮定は有効か？」 | sym_findで証拠を検索 |

### 統合パターン

```markdown
## 因果チェーン分析中の需要駆動探索

### [実装]レベル分析時:
1. 需要を生成: 各未定義動作に対して「trace-variable」需要を生成
2. 実行: repograph_localizeで変数定義を検索
3. キャッシュ: 発見内容を探索コンテキストに保存
4. 再開: 新しいコンテキストで分析を継続

### [設計]レベル分析時:
1. 需要を生成: インターフェース仮定に対して「check-contract」需要を生成
2. 実行: sym_findでインターフェース定義を検索
3. 検証: 仮定と実際の契約を比較
4. 再開: 不一致がある場合は因果チェーンを更新

### [契約]レベル分析時:
1. 需要を生成: 呼び出し関係に対して「trace-call」需要を生成
2. 実行: repograph egograph検索（k=2）で呼び出し元/先を特定
3. 検証: 契約の整合性を確認
4. 再開: 契約違反がある場合は原因として記録
```

### 探索コンテキストテンプレート

```markdown
## 探索コンテキスト

### アクティブな需要
- [ ] 需要1: <タイプ> - <説明> - <ステータス>
- [ ] 需要2: <タイプ> - <説明> - <ステータス>

### キャッシュされた発見
- 発見1: <何が見つかったか> - <ソース> - <タイムスタンプ>
- 発見2: <何が見つかったか> - <ソース> - <タイムスタンプ>

### 需要の伝播
- 親需要: <元の需要>
- 子需要: <派生した需要>
- 理由: <なぜ伝播したか>
```

### 需要駆動探索の停止条件

- [ ] すべてのアクティブな需要が解決された
- [ ] 因果チェーンが[意図]レベルに到達した
- [ ] 最大探索深度に到達した（デフォルト: 5）
- [ ] 矛盾が発見された（停止して報告）

### 実践例

```markdown
## 例: TypeError: Cannot read property 'id' of undefined

### 初期症状
user.controller.ts:45で `user.id` へのアクセス時にTypeError

### 需要駆動探索フロー

#### ステップ1: [実行]レベル
- 現象: userがundefined
- **需要生成**: `trace-variable` - "userの値の出所を追跡"

#### ステップ2: 変数追跡
- **実行**: repograph_localize({ task: "userの定義元", k: 2 })
- **発見**: user = getUserFromCache(userId) (user.controller.ts:30)
- **需要生成**: `trace-call` - "getUserFromCacheの実装を確認"

#### ステップ3: 呼び出し先調査
- **実行**: sym_find({ name: "getUserFromCache" })
- **発見**: user.cache.ts:15 - キャッシュミス時にnullを返す実装
- **需要生成**: `check-contract` - "getUserFromCacheの契約を確認"

#### ステップ4: 契約確認
- **実行**: sym_find({ name: "getUserFromCache", includeJSDoc: true })
- **発見**: JSDocに「@returns User | null」の記載なし
- **判定**: 契約の不明確さが真の原因

### 因果チェーン更新
- [実装] userがundefinedだった
- [設計] getUserFromCacheがnullを返す可能性がある
- [契約] getUserFromCacheの戻り値契約が不明確

### 探索終了条件
- [x] 因果チェーンが[契約]レベルに到達
- [x] 修正案が再発防止につながる（契約の明確化）
```

### repograph-localizationとの連携

```
┌─────────────────────────────────────────────────────────────┐
│              需要駆動探索 × RepoGraph連携                    │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  bug-hunting                repograph-localization          │
│  ───────────                ─────────────────────          │
│                                                             │
│  需要生成 ──────────────────→ クエリ実行                     │
│  (trace-variable)                                          │
│                                                             │
│  コンテキスト ←───────────── 結果返却                        │
│  (定義元情報)                  (egographノード)              │
│                                                             │
│  需要伝播 ──────────────────→ 追加クエリ                     │
│  (子需要の生成)                (k-hop拡張)                   │
│                                                             │
│  キャッシュ保存 ←──────────── 分析結果                       │
│                                (パス情報)                    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 設定パラメータ

| パラメータ | デフォルト値 | 説明 |
|-----------|------------|------|
| `maxExplorationDepth` | 5 | 最大探索深度 |
| `explorationTimeout` | 60000 | 探索タイムアウト（ms） |
| `cacheTTL` | 300000 | キャッシュ有効期限（ms） |
| `parallelDemands` | 3 | 並列実行する需要の最大数 |
