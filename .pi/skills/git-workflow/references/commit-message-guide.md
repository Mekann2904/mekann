# コミットメッセージガイドライン

現在のベストプラクティスに基づくコミットメッセージの書き方ガイド。

## 基本方針

- **絵文字は使用しない**
- **日本語で詳細に書く**
- **Body（本文）を必ず書く**

## コンセプト

以下の3つのコンセプトで運用:
- 巨人の肩の上に立つ
- フォーマットを覚えるコストが低い
- ミニマルな手がかりが掴める

### フォーマットを設ける理由

コミットメッセージは:
- リポジトリという地層の断片
- 自分を含む未来の開発者に向けて書くもの
- リポジトリの歴史やコンテキストを理解するための手がかりであるべき

一定の規律=フォーマット（Not ルール）を設けることで:
- チームがスケールしてもその手がかりを失わない
- フォーマットを設けることで考えることを一つでも減らす

## フォーマット

Conventional Commitsをベースに、日本語での詳細な記述を推奨。

```
<Type>[(scope)]: #<Issue Number> <Title>

<Body>

<Footer>
```

**例:**
```
feat(auth): #123 ユーザー認証にJWTを導入する

## 背景
現在のセッション認証は複数サーバー間で共有できないため、
スケールアウト時に問題が発生していた。

## 変更内容
- Passport.jsによるJWT認証を実装
- アクセストークンとリフレッシュトークンの二層構造

## テスト方法
1. POST /api/auth/login でトークン取得
2. GET /api/auth/me で認証確認

reviewed-by: 田中さん
```

### 構成要素

| 要素 | 必須度 | 説明 |
|------|--------|------|
| Type | 必須 | コミットの種別 |
| (scope) | 任意 | 影響範囲（api, ui, db等） |
| Issue Number | 強く推奨 | 紐づくIssue番号 |
| Title | 必須 | 変更内容の要約（50文字以内） |
| Body | **必須** | 詳細な説明（What, Why, How） |
| Footer | 任意 | 参照情報、レビュー者等 |

## Type一覧

| Type | 説明 | バージョン影響 |
|------|------|---------------|
| `feat` | ユーザー向けの機能の追加や変更 | Minor bump |
| `fix` | ユーザー向けの不具合の修正 | Patch bump |
| `feat!` / `fix!` | 破壊的変更 | Major bump |
| `docs` | ドキュメントの更新 | None |
| `style` | フォーマットなどのスタイルに関する修正 | None |
| `refactor` | リファクタリングを目的とした修正 | None |
| `test` | テストコードの追加や修正 | None |
| `chore` | タスクファイルなどプロダクションに影響のない修正 | None |
| `perf` | パフォーマンス改善 | Patch bump |
| `ci` | CI設定の変更 | None |

**注意**: オレオレルールで運用すると種別が覚えられない・浸透しないため、Conventional Commitsのレールに乗ることを推奨。

## Scope（スコープ）

影響範囲を限定する場合に使用:

```
feat(api): ユーザーAPIに検索機能を追加する
fix(ui): ダークモードでのボタン表示を修正する
docs(readme): インストール手順を更新する
```

**よく使うスコープ:**

| Scope | 用途 |
|-------|------|
| `api` | API関連 |
| `ui` | UI/フロントエンド |
| `db` | データベース |
| `auth` | 認証関連 |
| `config` | 設定ファイル |
| `deps` | 依存関係 |

## Issue Number

そのコミットに紐づくIssue番号を書く:
- リンクになって、トラッキングがしやすい
- Issueがあると修正意図が理解しやすい

**注意**: デフォルトの設定だと `#` がコメント扱いになるため、Typeの後に配置。

```
feat: #123 ログイン機能を実装する
```

**キーワード:**

| キーワード | 動作 |
|-----------|------|
| `Fixes #123` | マージ時にIssueをクローズ |
| `Closes #123` | マージ時にIssueをクローズ |
| `Resolves #123` | マージ時にIssueをクローズ |
| `Related to #123` | 参照のみ |

## Subject（タイトル）

### 書き方のルール

1. **現在形で書く**: 「◯◯した」ではなく「◯◯する」
2. **50文字以内**: ツール互換性のため
3. **具体的に**: 「テストを書く」「Lintエラーを修正する」等の曖昧な表現は避ける
4. **絵文字禁止**: 絵文字は使用しない

### 良い例

```
feat(auth): #101 ユーザー登録時に確認メールを送信する
fix(api): #89 ログイン時のセッションタイムアウトを修正する
refactor(db): #77 認証ロジックをサービスクラスに分離する
```

### 悪い例

```
feat: 機能追加                    ← 具体性がない
fix: バグ修正                     ← どのバグか不明
test: テストを書く                ← 何のテストか不明
feat: ✨ ログイン機能を実装する   ← 絵文字を使用している
```

## Body（本文）の書き方

**Bodyは必ず書く。** 以下の内容を含める:

### 必須要素

1. **背景（Why）**: なぜこの変更が必要なのか
2. **変更内容（What）**: 何を変更したのか
3. **実装方法（How）**: どのように実装したか（重要な場合）
4. **テスト方法**: どうテストしたか
5. **影響範囲**: 他に影響する部分はあるか

### 書き方のルール

- **72文字で折り返す**: `git log` で読みやすくするため
- **空行で段落を分ける**: 読みやすさのため
- **日本語で書く**: チーム内のコミュニケーションのため
- **見出しを使う**: `## 背景`, `## 変更内容` 等

### テンプレート

```
<Type>[(scope)]: #<Issue Number> <Title>

## 背景
<なぜこの変更が必要か>

## 変更内容
<具体的な変更点>

## 実装方法
<どう実装したか（必要な場合）>

## テスト方法
<どうテストしたか>

## 影響範囲
<他に影響する部分>

<Footer>
```

### 良いBodyの例

```
feat(api): #45 決済APIのタイムアウトを60秒に延長する

## 背景
本番環境で、処理に30秒以上かかる決済リクエストが
タイムアウトエラー（504）になっていた。
カスタマーサポートに多数の問い合わせが来ていた。
分析の結果、95%のリクエストは45秒以内に完了するが、
残り5%は最大55秒かかることが分かった。

## 変更内容
- API Gatewayのタイムアウトを30秒から60秒に延長
- 決済API呼び出し前にタイムアウト警告ログを出力
- フロントエンドのローディング表示を60秒に延長

## テスト方法
1. 負荷テストツールで40秒のレスポンスを模擬
   `artillery run load-test.yml`
2. ステージング環境で実際の決済フローを確認
3. タイムアウト警告ログが正しく出力されることを確認

## 影響範囲
- フロントエンド: loading-timeout.ts の修正が必要
- モニタリング: 60秒超過のアラート設定を追加

## デプロイ先
dev-60（dev-59はDB不整合のため使用不可）
本番反映は来週のリリース予定

resolves: #45
related-pr: #47
```

```
refactor(auth): #78 セッション認証をJWTに移行する

## 背景
現在のセッション認証は以下の問題があった:
- 複数サーバー間でセッションを共有できない
- モバイルアプリとの連携でセッション管理が複雑
- スケールアウト時にセッションストアがボトルネック

## 変更内容
- Passport.jsによるJWT認証を実装
- アクセストークン（15分）とリフレッシュトークン（7日）の二層構造
- トークン無効化用のブラックリストをRedisに実装
- 既存のセッション認証コードを削除

## 実装方法
- jsonwebtoken ライブラリを使用
- リフレッシュトークンは HttpOnly Cookie に保存
- アクセストークンは Authorization Header で送信
- トークン検証はミドルウェアで実装

## テスト方法
1. ユーザー登録: POST /api/auth/register
2. ログイン: POST /api/auth/login
   - アクセストークンとリフレッシュトークンを確認
3. APIアクセス: GET /api/auth/me (Bearer Token)
4. トークン更新: POST /api/auth/refresh
5. ログアウト: POST /api/auth/logout
   - トークンがブラックリストに追加されることを確認

## 影響範囲
- 既存ユーザー: 再ログインが必要
- モバイルアプリ: トークン管理の修正が必要（別PR #80）
- ドキュメント: API仕様書の更新が必要

## 移行計画
1. ステージング環境で動作確認
2. モバイルアプリの修正完了を待つ
3. 本番デプロイ（メンテナンス時間帯）

breaking-change: 既存セッションは無効化されます
reviewed-by: 田中さん、佐藤さん
related-pr: #80
```

### Bodyを書かないでいいケース

以下の場合はBodyがなくてもよい:

```
docs: #12 READMEのタイポを修正する
```

```
style: #15 コードフォーマットを適用する
```

これらは変更内容が自明なため、Bodyがなくても理解できる。

---

## Footer（フッター）

本文で目立たせる情報はフッターに記載。

### よく使うフッター

| フッター | 説明 | 例 |
|---------|------|-----|
| `resolves` | 解決するIssue | `resolves: #123` |
| `related-pr` | 関連PR | `related-pr: #456` |
| `reviewed-by` | レビューした人 | `reviewed-by: 田中さん` |
| `co-authored-by` | 共同作成者 | `co-authored-by: 佐藤さん` |
| `breaking-change` | 破壊的変更の説明 | `breaking-change: API仕様が変更されます` |

---

## 日本語か？英語か？

**このプロジェクトでは日本語で書くことを推奨。**

### 日本語を採用するメリット

- ネイティブでない英語で書くと時間がかかる
- 急いでいると文法も怪しいメッセージになりがち
- ドメスティックなチーム・サービスなら日本語で十分
- 詳細な説明を書きやすい

### 英語が必要なケース

- グローバルなチーム
- オープンソースプロジェクト
- 英語圏のクライアント

---

## コミットの粒度

- **小さくすることを基本とする**
- ただし、常に1行の修正ごとにコミットすればOKというわけではない
- レビュアーがPull Requestのコミット一覧を見たときに"ストーリー"が分かることを意識

### 良い粒度の例

```
feat(auth): #50 ログインフォームのコンポーネントを作成する

## 背景
ユーザー認証機能の第一歩として、ログインフォームのUIを作成する。

## 変更内容
- LoginForm コンポーネントを作成
- バリデーションロジックを実装
- エラーメッセージ表示を追加

## テスト方法
- Storybook でフォームの表示確認
- バリデーションが正しく動作することを確認
```

```
feat(auth): #50 ログインAPIとフォームを連携する

## 背景
前回のコミットで作成したログインフォームを
バックエンドAPIと連携させる。

## 変更内容
- API呼び出しロジックを追加
- ローディング状態の管理を実装
- 成功/失敗時のハンドリングを追加

## テスト方法
- 正しい認証情報でログイン成功を確認
- 誤った情報でエラー表示を確認
```

```
test(auth): #50 ログインフォームのテストを追加する

## 背景
ログイン機能の品質を保証するため、
ユニットテストとE2Eテストを追加する。

## 変更内容
- Jest でユニットテストを追加
- Cypress でE2Eテストを追加
- テストケース:
  - 正常系: 正しい認証情報でログイン
  - 異常系: 空入力、誤った認証情報

## テスト方法
- npm run test でユニットテスト実行
- npm run e2e でE2Eテスト実行
```

### 細かすぎる例

```
feat: #50 ログインフォームのHTMLを書く
feat: #50 ログインフォームにCSSを当てる
feat: #50 ログインフォームにバリデーションを追加する
```

→ これらは1つのコミットにまとめるべき

---

## 例外

以下はこのフォーマットに従う必要はない:
- Merge Commit（自動生成）
- Revert Commit（自動生成）

---

## 詳細ガイド（上級編）

以下はより詳細なコミットメッセージの書き方。

### コミットメッセージの重要性

**レビュー時間を短縮:**
- コードは「何を」説明するが、メッセージは「なぜ」を説明
- 不明確なPRは「来週見る」と先送りされる
- 良いコミットメッセージはレビュアーの脳容量を節約

**Gitネイティブツールとの連携:**
- PRはGitネイティブではない（GitHub固有）
- コミットは `git bisect`, `git blame`, `git revert` 等のツールで活用可能
- バグ調査時にコミットメッセージが重要な手がかりになる

### タイトルの詳細ルール

**文字数:**
- 72文字以内（GitHubでトランケートされるのを防ぐ）
- 50文字以内が理想

**構造:**
```
<Type>[!][(scope)]: #<Issue Number> <Title>
```

| 要素 | 説明 |
|------|------|
| `!` | 破壊的変更 |
| `(scope)` | 影響範囲（api, ui, db等） |

**破壊的変更:**
- ユーザーが期待する動作を壊す変更
- 知らないとバグを引き起こす可能性がある変更

**例:**
```
feat!: #89 バーガー型定義を変更する
feat!(api): #90 バーガーメーカーハンドラを追加する
fix!(db): #91 ユーザーテーブルスキーマを移行する
```

### Body（本文）の書き方

コミットはドキュメントであるため、良い本文を書く。

**`git commit -m` なしでコミット:**
- エディタが開き、1行目がタイトル、空行、本文
- GitHubはコミット本文をPRの説明として使用

#### テスト方法を書く

「テストした」だけでは不十分:
- どうテストしたか？
- 自動テストか手動テストか？
- どのエッジケースをテストしたか？

**良い例:**
```
feat(api): #45 バーガーメーカーエンドポイントを追加する

## 背景
モバイルアプリからバーガー注文を受け付けるための
APIエンドポイントが必要だった。

## 変更内容
- POST /api/burger エンドポイントを実装
- バリデーションロジックを追加
- エラーレスポンスを統一

## テスト方法
1. ローカルサーバー起動: `npm run dev`
2. テストユーザー作成: `curl -X POST localhost:3000/api/users`
3. バーガーエンドポイントテスト:
   curl -X POST localhost:3000/api/burger \
     -H "Content-Type: application/json" \
     -d '{"type": "cheese"}'
4. レスポンスにバーガーオブジェクトが含まれることを確認

## デプロイ先
dev-60（dev-59はDB不整合のため使用不可）
```

#### デプロイ先を書く

複数環境がある場合:
- どこにデプロイされているか？
- どの環境でテストされたか？
- 本番のどこにデプロイされるか？

**重要な理由:**
- DB変更は環境によって結果が異なる
- セキュリティ要件が異なる
- 内部ツール vs 外部サービス

### Footers（フッター）

本文で目立たせる情報はフッターに。

**形式:**
```
<key>: <value>
```

**よく使うフッター:**

| フッター | 説明 | 例 |
|---------|------|-----|
| `reviewed-by` | レビューした人 | `reviewed-by: 田中さん（セキュリティ）` |
| `slack-channel` | 関連Slackチャンネル | `slack-channel: #api-changes` |
| `incident` | 関連インシデント | `incident: INC-456` |
| `co-authored-by` | 共同作成者 | `co-authored-by: 佐藤さん` |

**例:**
```
feat(auth): #56 二要素認証を追加する

## 背景
アカウント乗っ取り被害が増加しているため、
セキュリティ強化の一環として二要素認証を導入する。

## 変更内容
- TOTP対応の二要素認証を実装
- 設定画面に二要素認証ON/OFFを追加
- バックアップコード生成機能を追加

## テスト方法
1. 設定画面で二要素認証を有効化
2. Google Authenticatorでコード確認
3. ログイン時に二要素認証が要求されることを確認

reviewed-by: 田中さん（セキュリティ担当）
slack-channel: #security-updates
incident: INC-789
```

### 完全テンプレート

```
<Type>[!][(scope)]: #<Issue Number> <Title>

## 背景
<なぜこの変更が必要か>

## 変更内容
<具体的な変更点>

## テスト方法
<どうテストしたか>

## 影響範囲
<他に影響する部分>

<Footer>
```

**使用例:**
```
feat!(api): #89 バーガー型定義を変更する

## 背景
フロントエンドとバックエンドで型定義が不一致だったため、
API仕様を統一する必要があった。

## 変更内容
- Burger型にcaloriesフィールドを追加
- priceフィールドをnumberからstringに変更
- 既存のprice使用箇所をすべて修正

## テスト方法
1. ユニットテスト実行: `npm test`
2. 手動APIテスト:
   curl -X GET localhost:3000/api/burger/123
3. TypeScriptの型定義を確認

## 影響範囲
- フロントエンド: 価格表示ロジックの修正が必要
- モバイルアプリ: 同様の修正が必要（別PR #91）

## デプロイ先
dev-60でテスト中
本番はprod-ap-northeast-1にデプロイ予定

reviewed-by: 田中さん
slack-channel: #api-changes
```

### アトミックコミット

コミットが小さく自己完結している場合、詳細な本文は不要:

```
docs(readme): #12 タイポを修正する
```

```
style: #15 コードフォーマットを適用する
```

これらは変更内容が自明なため、Bodyがなくても理解できる。

---

## コミットメッセージの哲学（Linuxカーネルスタイル）

### なぜコミットメッセージが重要か

あらゆるソフトウェアプロジェクトは共同作業です。少なくとも2人の開発者――オリジナルの開発者と、数週間あるいは数ヶ月後に思考の流れがすっかり変わってしまった頃の開発者――が関わっています。

**コードのコンテキストを再構築することは非効率な作業です。** 完全に回避することはできませんが、その影響を最小限に抑える努力はすべきです。

> 「コミットメッセージは開発者の協調性を測る指標となる」

### 優れたコミットメッセージが答えるべき3つの問い

優れたコミットメッセージは、パッチに関して以下の3つの問いに答えるものでなければなりません:

#### 1. なぜ必要なのか？

- バグ修正？
- 新機能の追加？
- パフォーマンス/信頼性/安定性の向上？
- 技術的正確性のための変更？

#### 2. この変更はどのように問題に対処しているか？

- 簡潔で明白な修正の場合は省略可
- 変更のアプローチについての概要レベルの説明を記載

#### 3. このパッチはどのような影響をもたらしますか？

- 明白な影響事項
- ベンチマーク結果
- 副次的効果

**これら3つの質問は、実際のコード変更の背景を明確にし、レビュアーやその他の関係者が差分を確認した際に、採用されたアプローチの妥当性を適切に判断できる状態を整えるものです。**

### 不適切なコミットメッセージのコスト

これらの疑問に対する回答が記載されていないパッチは、ほぼ価値がありません:

- すべてのレビュアーが個別に調査を行う必要がある
- レビュアーの人数が多いほど、多大な時間が無駄になる
- メンテナーがSCMの規律を徹底している場合、パッチは拒否される
- 開発者は再度パッチを書き直す時間を費やす必要がある

> コミットメッセージの作成に要する時間はわずか数分であることを考えると、これを省略したり質の低いものにしたりすることは、経済的に全く合理性がありません。

---

## やってはいけない方法（アンチパターン）

### 1. SCMをバックアップシステムとして使う

毎日の終わりにすべての変更をまとめてコミットする開発者は、無意味な変更履歴を作成してしまいます。数ヶ月も経てば元の作成者でさえ理解不可能な、コード全体に散在するランダムな差分となってしまいます。

**悪い例:**
```
chore: 日次コミット
```

### 2. ファイル単位のコミット

論理的な変更は複数のファイルに影響を及ぼすことが多く、これを複数のコミットに分割すべきではありません。

**悪い例:**
```
fix: user.js でバグ修正
fix: utils.js も修正
fix: config.js も更新
```

### 3. 曖昧なコミットメッセージ

「各種修正とクリーンアップ」といった曖昧なコミットメッセージは、必ず後で問題が表面化します。

- バグの発生箇所を特定するのがほぼ不可能
- バイセクティング（バグの原因を特定する手法）も困難
- プロジェクトの進行状況を他のメンバーが把握するのも難しい

**悪い例:**
```
chore: いろいろ修正
fix: バグ修正
refactor: クリーンアップ
```

### 4. 1つのパッチに複数の変更を含める

**悪い例:**
```
fix: バグ2345を修正し、すべての'foo'を'bar'に改名
```

バグ2345の修正に改名が必ずしも必要でない場合、これらの変更は別々のパッチに分割すべきです。他の開発者が安定ブランチに特定のバグ修正を適用したい場合、両方の変更を適用する必要が生じる可能性があります。

### 5. コード変更に伴う無関係な空白文字の変更

干し草の山の中の針を探すような作業はパッチレビューでは歓迎されません。特に、単なる見栄えの改善のためにインデントが変更された数百行の中にバグが巧妙に隠されている場合、誰もそのバグを発見できない可能性が高いため、これは重大なバグ導入の原因となります。

**推奨:**
- 空白文字の変更は別のコミットにする
- インデントの変更は慎重に行う

### 6. 実に厄介なコード変更の塊

新機能を実装するために数百行に及ぶコードを挿入するパッチでありながら、同時に既存のインフラストラクチャの半分を書き換えるという代物です。

**より良い方法:**
1. まずインフラストラクチャを少しずつ再構築
2. その後新しい機能をその上に追加

**副次的な影響:** プロジェクトがコードダンプに過度に依存している場合、外部の開発者を遠ざける要因となります。

---

## より良い方法（ベストプラクティス）

### 1つのコミット = 1つの論理的な変更

1つのコミットには、正確に1つの論理的な変更を含めるべきです:

- 新機能の追加
- 特定のバグ修正
- パフォーマンス改善

**判断基準:** 変更の概要を数語で表現できない場合、それは単一のコミットにまとめるには複雑すぎる可能性が高いです。

**原則として:** コミットメッセージだけを見て、他の開発者が合理的な時間内で同じパッチを実装できる状態が望ましいです。

### git add -p を活用する

Gitを使用している場合は、`git add -p`（または`-i`）コマンドを活用して、変更内容を論理的な単位のコミットに分割する習慣をつけましょう。

```bash
# 変更を対話的に選択してステージング
git add -p

# または対話モード
git add -i
```

### コミットメッセージの形式

1. **1行目:** 変更内容の簡潔な要約（50〜72文字以内）
2. **空行**
3. **本文:** パッチの詳細説明（コードではなく、意図と実装方法を説明）
4. **現在形で記載**

```
<Type>[(scope)]: #<Issue Number> <Title>

## 背景
<なぜ必要なのか>

## 変更内容
<どのように問題に対処しているか>

## 影響
<どのような影響をもたらすか>
```

### ログを愛する

コードファイルよりも頻繁に `git log` を確認しましょう:

- `git log` は強力なツール
- `git blame` を日常的に使用
- これらは時間と労力を大幅に節約する

---

## 素晴らしいGitコミットメッセージの7つのルール

以下の7つのルールに従うことで、プロフェッショナルなコミットメッセージを書くことができます。

### ルール1: SubjectとBodyを空行で区切る

git commitのmanpageから:

> コミットメッセージは、変更を要約する1行（50文字以内）で始め、その後に空行を入れ、より詳細な説明を続けることが推奨される。最初の空行までのテキストはコミットタイトルとして扱われ、Git全体で使用される。

**すべてのコミットにSubjectとBodyの両方が必要なわけではありません。** 変更がシンプルで追加のコンテキストが不要な場合は、1行で十分です:

```
docs: #12 ユーザーガイドのイントロダクションの誤字を修正する
```

しかし、コミットが少し説明とコンテキストを必要とする場合は、Bodyを書く必要があります:

```
feat(security): #45 マスターコントロールプログラムを無効化する

MCPが邪悪であることが判明し、世界征服を目論むようになった。
このコミットはTronのディスクをMCPに投げ込み（デレゾリューションを引き起こし）、
チェスゲームに戻す。

resolves: #45
```

**重要:** `git log --oneline`、`git shortlog`などのツールは、空行がないと正しく動作しません。

### ルール2: Subject行を50文字以内にする

50文字は厳密な制限ではなく、目安です。この長さを守ることで:
- 読みやすさが確保される
- 最も簡潔な説明方法を考えるきっかけになる

**ヒント:** まとめるのが難しい場合、一度に太多くの変更をコミットしている可能性があります。アトミックコミットを心がけましょう。

**制限:**
- 目標: 50文字以内
- 絶対上限: 72文字（GitHubでトランケートされる）

### ルール3: Subject行の先頭を大文字にする

シンプルですが重要です。Subject行はすべて大文字で始めます。

**良い例:**
- `feat: #10 88マイル毎時まで加速する`

**悪い例:**
- `feat: #10 88マイル毎時まで加速する`（先頭が小文字）

### ルール4: Subject行をピリオドで終えない

Subject行の末尾に句読点は不要です。50文字以内を目指す上で、スペースは貴重です。

**良い例:**
- `fix: #20 ポッドベイのドアを開く`

**悪い例:**
- `fix: #20 ポッドベイのドアを開く。`

### ルール5: Subject行で命令形を使う

命令形とは「命令や指示として話す/書く」ことです:

- 部屋を掃除する
- ドアを閉める
- ゴミを出す

**なぜ命令形を使うのか:** Git自体があなたの代わりにコミットを作成する際、命令形を使用するからです:

```
git merge → "Merge branch 'myfeature'"
git revert → "Revert \"Add the thing with the stuff\""
GitHub マージ → "Merge pull request #123 from someuser/somebranch"
```

**良い例:**
- `refactor: #30 サブシステムXを読みやすくリファクタリングする`
- `docs: #31 入門ドキュメントを更新する`
- `fix: #32 非推奨メソッドを削除する`
- `chore: #33 バージョン1.0.0をリリースする`

**悪い例:**
- `fix: #34 Yのバグを修正した`（過去形）
- `refactor: #35 Xの振る舞いを変更中`（進行形）
- `fix: #36 壊れたものの修正`（名詞句）

**判断基準:** 適切に形成されたGitコミットのSubject行は、常に以下の文を完成させることができるはずです:

> 「このコミットを適用すると、___」

- 「このコミットを適用すると、_サブシステムXを読みやすくリファクタリングする_」
- 「このコミットを適用すると、_入門ドキュメントを更新する_」
- 「このコミットを適用すると、_非推奨メソッドを削除する_」

**注意:** 命令形の使用はSubject行でのみ重要です。Bodyを書く際はこの制限を緩和できます。

### ルール6: Bodyは72文字で折り返す

Gitはテキストを自動的に折り返しません。コミットメッセージのBodyを書く際は、右マージンを意識し、手動でテキストを折り返す必要があります。

推奨は72文字です。これにより、Gitがテキストをインデントしても、全体が80文字以内に収まります。

**実装:** エディタで72文字のルーラーを設定するか、Gitコミット時に自動折り返しを有効にする。

### ルール7: Bodyで「何を」と「なぜ」を説明する（「どう」ではない）

コードは一般的に「どう」変更されたかを説明します（コードが複雑で説明が必要な場合は、ソースコードコメントがそのためのものです）。

Bodyでは以下に焦点を当てます:
- **なぜ変更したのか**
- 変更前の動作（何が問題だったのか）
- 変更後の動作
- なぜその解決方法を選んだのか

**良い例:**
```
refactor: #50 serialize.hの例外処理を簡素化する

serialize.hのストリーム実装から'state'と'exceptmask'を削除し、
関連するメソッドも削除する。

exceptmaskは常に'failbit'を含み、setstateは常にbits = failbitで
呼び出されていたため、即座に例外を発生させるだけだった。
これらの変数を削除し、setstateを直接例外スローに置き換える
（これによりデッドコードも削除される）。

結果として、失敗後にgood()が到達することはなく（テスト内の
2つの呼び出しのうち1つだけ）、単に!eof()で置き換えできる。

fail()、clear(n)、exceptions()は呼び出されないため削除する。
```

**未来のメンテナー（それはあなた自身かもしれません！）が感謝するでしょう。**

---

## コミットメッセージテンプレート（完全版）

```
<Type>[(scope)]: #<Issue Number> <Title>

## 背景
<なぜこの変更が必要なのか>

## 変更内容
<具体的な変更点>

## テスト方法
<どうテストしたか>

## 影響範囲
<他に影響する部分>

<Footer>
```

**日本語での例:**
```
feat(api): #45 決済APIのタイムアウトを60秒に延長する

## 背景
本番環境で、処理に30秒以上かかる決済リクエストが
タイムアウトエラー（504）になっていた。
カスタマーサポートに多数の問い合わせが来ていた。

分析の結果、95%のリクエストは45秒以内に完了するが、
残り5%は最大55秒かかることが分かった。

## 変更内容
- API Gatewayのタイムアウトを30秒から60秒に延長
- 決済API呼び出し前にタイムアウト警告ログを出力
- フロントエンドのローディング表示を60秒に延長

## テスト方法
1. 負荷テストツールで40秒のレスポンスを模擬
   `artillery run load-test.yml`
2. ステージング環境で実際の決済フローを確認
3. タイムアウト警告ログが正しく出力されることを確認

## 影響範囲
- フロントエンド: loading-timeout.ts の修正が必要
- モニタリング: 60秒超過のアラート設定を追加

## デプロイ先
dev-60（dev-59はDB不整合のため使用不可）
本番反映は来週のリリース予定

resolves: #45
related-pr: #47
reviewed-by: 田中さん
```

---

## よくある言い訳と反論

### 「でもこれで動いているから問題ない！」

**反論:** コードは静的な存在ではありません。数週間も経てば:
- コードは移動されている
- 書き直されている
- 別の名称で呼ばれている
- バグが含まれている可能性がある
- 元の開発者はすでに別のプロジェクトに移っている
- なぜこのコードが現在の形になっているのか、誰も知らない

**最悪の場合:** 誰もその仕組みを正確に理解していないため、誰もが修正をためらってしまう。

### 「自分一人しかこのコードを触っていないから」

**反論:** これは事実ではありません。あらゆるソフトウェアプロジェクトは本質的に共同作業です:
- テスター
- 開発者
- バグトリアージ担当者
- ユーザー
- 未来の自分

特にオープンソースプロジェクトにおいては、外部の協力者に大きく依存しています。これらの協力者が参加しにくくなるほど、プロジェクトが失敗する可能性が高まります。

### 「バージョン管理システムが遅い」

**反論:** 分散型バージョン管理システム（Git）はこの問題を回避できるため、時間の節約につながり、結果としてコストの削減が可能になります。

---

## まとめ

- **絵文字は使用しない**
- **日本語で詳細に書く**
- **Body（本文）を必ず書く**
- フォーマットは手段であり目的ではない
- チームの状況に合わせて調整する
- 良いコミットメッセージは未来の自分とチームを助ける

---

## 参考資料

- [How to Write a Git Commit Message](https://cbea.ms/posts/git-commit/) by Chris Beams（7つのルール）
- [自分だけのコミットメッセージでライバルに差をつけろ！](https://zenn.dev/itosho/articles/git-commit-message-2023) by itosho
- [On Commit Messages](http://who-t.blogspot.com/2009/12/on-commit-messages.html) by Peter Hutterer（Linuxカーネルスタイル）
- [How to Write a Git Commit Message](https://skerritt.blog/how-to-write-a-git-commit-message/) by Skerritt
- [8 Git Commit Message Best Practices](https://blog.pullnotifier.com/blog/git-commit-message-best-practices) by PullNotifier
- [Conventional Commits](https://www.conventionalcommits.org/)
- [Pro Git](https://git-scm.com/book/en/v2) - 無料オンラインブック
- [commitlint](https://github.com/conventional-changelog/commitlint) - コミットフォーマット検証
- [Commitizen](https://github.com/commitizen/cz-cli) - 対話的コミット作成
- [semantic-release](https://github.com/semantic-release/semantic-release) - 自動リリース
