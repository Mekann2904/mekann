# コードカバレッジ ベストプラクティス

Googleの「Code Coverage Best Practices」に基づく実践ガイド。

## 目標設定

### カバレッジ率のガイドライン

| 率 | 評価 | 適用場面 |
|---|------|---------|
| **< 60%** | 不十分 | 最低限の改善が必要 |
| **60%** | 許容範囲 | 標準的なプロジェクトの最低ライン |
| **75%** | 称賛に値する | 品質重視のプロジェクト |
| **90%** | 模範的 | ミッションクリティカルな機能 |
| **> 95%** | 過剰可能性 | ROIを再検討 |

### 判断基準

```yaml
# カバレッジ目標設定の意思決定マトリクス

高目標が必要（85%+）:
  - 決済・請求処理
  - 認証・認可
  - 個人情報取り扱い
  - 医療・金融ドメイン
  - 頻繁に変更されるコアロジック

中程度の目標（70-85%）:
  - 一般的なビジネスロジック
  - APIエンドポイント
  - データ変換処理
  - 定期的に更新される機能

低めの目標可（60-70%）:
  - UIコンポーネント
  - デバッグ・ロギング
  - 一時的なスクリプト
  - 頻繁に変更されないユーティリティ

除外検討:
  - 自動生成コード
  - サードパーティ統合
  - デッドコード（削除すべき）
```

## カバレッジタイプ

### カバレッジの種類

| タイプ | 説明 | 特徴 |
|--------|------|------|
| **行カバレッジ** | 実行されたコード行の割合 | 最も一般的 |
| **分岐カバレッジ** | 実行された分岐の割合 | より厳密 |
| **関数カバレッジ** | 呼び出された関数の割合 | 大雑把 |
| **条件カバレッジ** | 評価された条件の割合 | 最も厳密 |

### 推奨カバレッジタイプ

```
優先順位:
1. 分岐カバレッジ（Branch Coverage）を優先
2. 行カバレッジは参考程度
3. 条件カバレッジは複雑なロジックで検討

理由:
- 分岐カバレッジはif文の両方のパスを考慮
- 行カバレッジだけでは条件分岐の網羅性を保証できない
```

## 新規コード vs 既存コード

### 戦略の使い分け

```
┌─────────────────────────────────────────────────────────────┐
│                    カバレッジ戦略                            │
├──────────────────────┬──────────────────────────────────────┤
│     新規コード        │           既存コード                  │
├──────────────────────┼──────────────────────────────────────┤
│ 目標: 90-99%         │ 段階的改善                            │
│ 下限: 90%            │ ボーイスカウト原則                     │
│ ゲート: 必須          │ 触れた部分から改善                     │
│ レビュー: 全行確認    │ 優先度に基づく改善                     │
└──────────────────────┴──────────────────────────────────────┘
```

### 新規コードの基準

```yaml
# 新規コードとみなす条件

新規コード（厳格ゲート適用）:
  - 新規ファイル
  - 新規関数・メソッド
  - 既存関数の大幅な変更（50%以上）

既存コード（段階的改善）:
  - 軽微な修正
  - リファクタリング（振る舞い不変）
  - ドキュメント更新
```

## カバレッジゲートの実装

### CI/CDパイプラインでのゲート

```yaml
# GitHub Actions の例
name: Coverage Gate

on: [pull_request]

jobs:
  coverage:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Run tests with coverage
        run: npm test -- --coverage

      - name: Check new code coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/lcov.info
          fail_ci_if_error: true

      - name: Enforce coverage threshold
        run: |
          # 新規コードは90%以上
          if [ $(cat coverage/new-code-coverage.txt) -lt 90 ]; then
            echo "New code coverage below 90%"
            exit 1
          fi

          # 全体は60%以上
          if [ $(cat coverage/total-coverage.txt) -lt 60 ]; then
            echo "Total coverage below 60%"
            exit 1
          fi
```

### ゲートの種類

```
1. ハードゲート（ブロック）
   - カバレッジ不足でマージ不可
   - 例外は明示的な承認が必要

2. ソフトゲート（警告）
   - カバレッジ不足で警告表示
   - マージは可能だが推奨しない

3. 差分ゲート
   - 前回との差分で判定
   - カバレッジ低下を防ぐ
```

## 未カバー部分の分析

### 分析プロセス

```
Step 1: 未カバー行の特定
        ↓
Step 2: カテゴリ分類
        - 重要なビジネスロジック
        - エラーハンドリング
        - エッジケース
        - デバッグコード
        - 自動生成コード
        ↓
Step 3: リスク評価
        - 影響度（高/中/低）
        - 発生頻度（高/中/低）
        - 検出難易度
        ↓
Step 4: 優先順位付け
        - 高リスク: 即座にテスト追加
        - 中リスク: スプリント内で対応
        - 低リスク: 技術的負債として管理
```

### 分析テンプレート

```markdown
## 未カバー領域分析

### ファイル: src/payment/processor.ts

| 行番号 | コード概要 | カテゴリ | リスク | 対応方針 |
|-------|-----------|---------|--------|---------|
| 45-52 | エラーハンドリング | 重要 | 高 | テスト追加必須 |
| 78-82 | デバッグログ | ロギング | 低 | 除外検討 |
| 95-110 | レアケース | エッジ | 中 | 検討後に判断 |

### 推奨アクション
1. [ ] 行45-52: 支払い失敗時のテストを追加
2. [ ] 行78-82: カバレッジ除外アノテーション追加
3. [ ] 行95-110: テストコストと価値を比較検討
```

## 単体テスト vs 統合テストのカバレッジ

### 統合ビューの構築

```
┌────────────────────────────────────────────────────────────┐
│                    統合カバレッジダッシュボード               │
├────────────────────────────────────────────────────────────┤
│                                                            │
│  全体カバレッジ: 72%                                        │
│  ├── 単体テスト: 65% (意図的)                               │
│  └── 統合テスト: 45% (一部偶発的)                           │
│                                                            │
│  未カバー領域:                                              │
│  ├── 単体・統合ともに未カバー: 28% ← 最優先                 │
│  ├── 単体のみカバー: 27%                                    │
│  └── 統合のみカバー: 7% ← 確認が必要                        │
│                                                            │
└────────────────────────────────────────────────────────────┘
```

### 注意点

```
統合テストカバレッジの特徴:
- 偶発的なカバレッジが含まれる
- 意図的なテストではない可能性
- 単体テストでカバーされていないからといって、
  統合テストでカバーされていると安心しない

推奨アプローチ:
1. 単体テストカバレッジをベースラインに
2. 統合テストカバレッジは補完として扱う
3. 両方に未カバーの領域を最優先
```

## アンチパターン

### 避けるべき実践

```
アンチパターン1: 数値の神格化
- 「100%達成」が目的化
- 品質より数値達成を優先
- チェックボックスとして扱う

アンチパターン2: 形式的なテスト
test('add function', () => {
  add(1, 2);  // アサーションなし
});

アンチパターン3: コピー＆ペースト
test('case 1', () => { expect(fn(1)).toBe(1); });
test('case 2', () => { expect(fn(2)).toBe(2); });
test('case 3', () => { expect(fn(3)).toBe(3); });
// プロパティベーステストで置き換えるべき

アンチパターン4: 除外の濫用
// istanbul ignore next
function importantFunction() { ... }
```

### 正しい実践

```
正しい実践1: 未カバー部分の分析重視
- 数値より何がテストされていないか
- リスクベースの判断

正しい実践2: 意味のあるテスト
test('add should sum two numbers', () => {
  expect(add(1, 2)).toBe(3);
  expect(add(-1, 1)).toBe(0);
  expect(add(0.1, 0.2)).toBeCloseTo(0.3);
});

正しい実践3: プロパティベーステスト
fc.assert(fc.property(
  fc.integer(), fc.integer(),
  (a, b) => add(a, b) === a + b
));

正しい実践4: 適切な除外
// istanbul ignore next - cannot test without hardware
function hardwareSpecificCode() { ... }
```

## ミューテーションテスト

### 概念

```
ミューテーションテスト:
- コードに意図的なバグ（ミュータント）を導入
- テストがミュータントを検出（失敗）すれば品質が高い
- テストがミュータントを検出しなければ品質が低い

ミュータントの種類:
- 算術演算子: + → -, * → /
- 比較演算子: > → >=, == → !=
- 論理演算子: && → ||, ! → (削除)
- 条件削除: if (cond) → if (true)
```

### ツール例

```bash
# Stryker (JavaScript/TypeScript)
npm install -g stryker-cli
stryker init
stryker run

# 結果例
Ran 150 mutants
- Killed: 135 (90%)
- Survived: 10 (7%)
- Timeout: 5 (3%)

# Survived ミュータントが多い = テスト品質が低い
```

## レポートと可視化

### カバレッジレポートの構成要素

```
┌─────────────────────────────────────────────────────────────┐
│                    カバレッジレポート                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  サマリー                                                    │
│  ├── 全体: 72% ████████████████████░░░░░░░░                 │
│  ├── 新規コード: 94% ████████████████████████░░             │
│  └── 前回比: +3%                                            │
│                                                             │
│  未カバーTop5                                                │
│  1. src/payment/error.ts (23%)                              │
│  2. src/auth/legacy.ts (31%)                                │
│  3. src/utils/debug.ts (45%)                                │
│                                                             │
│  トレンド                                                    │
│  Week 1: 65% → Week 2: 68% → Week 3: 72%                   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### PRでのカバレッジ表示

```markdown
## Coverage Report

| | Coverage | Diff |
|---|---------|------|
| Project | 72% | +2% |
| New Code | 94% | - |
| Patch | 89% | - |

### Uncovered Lines
- `src/feature/new.ts:45-52` - Error handling
- `src/feature/new.ts:78` - Debug log

### Recommendation
Consider adding tests for error handling (lines 45-52)
before merging.
```

## チェックリスト

### カバレッジ導入時

- [ ] カバレッジ目標をビジネス要件に基づいて設定
- [ ] 新規コードと既存コードで異なる基準を適用
- [ ] CI/CDパイプラインにカバレッジゲートを統合
- [ ] 未カバー部分の分析プロセスを確立
- [ ] チーム全体で運用ルールを合意

### カバレッジ改善時

- [ ] 未カバー領域をリスクで優先順位付け
- [ ] 重要なビジネスロジックから優先的にテスト追加
- [ ] 除外すべきコードを明示的にマーク
- [ ] ミューテーションテストでテスト品質を確認
- [ ] カバレッジ低下を防ぐゲートを設定

### レビュー時

- [ ] 未カバー行について実践的な議論
- [ ] 新規コードが目標閾値を満たしているか確認
- [ ] 重要なコードが適切にテストされているか確認
- [ ] 除外が適切か確認
