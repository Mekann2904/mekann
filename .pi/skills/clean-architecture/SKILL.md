---
name: clean-architecture
description: アーキテクチャ設計・レビュースキル。コンポーネントの凝集度・結合度の原則に基づき、保守性の高い「ソフトな」システムを構築。開発フェーズに応じた原則の重み付けを支援。
license: MIT
tags: [architecture, design-principles, cohesion]
metadata:
  skill-version: "1.0.0"
  created-by: pi-skill-system
  based-on: "Clean Architecture (Robert C. Martin)"
---

# Clean Architecture

アーキテクチャ設計とレビューを支援するスキル。システムを「ソフト（変更しやすい）」な状態に保つための原則と実践方法を提供する。

## 核心思想

### なぜ良いアーキテクチャが必要か

**システムの構築・保守に必要な人数を最小限に抑えるため。**

悪いアーキテクチャは時間とともに：
- 変更が困難になる
- リリースが遅くなる
- バグが増える
- 開発者の生産性が下がる

**ソフトウェアは常に「ソフト」であるべき。** 変更しづらいソフトウェアは危険。

### アーキテクトの責任

- 継続的に開発・運用できるシステムを維持する
- 選択肢を残しておく（詳細の決定を延期できるようにする）
- ユースケースを強調する

---

## 使用タイミング

以下の場合にこのスキルを読み込む：
- アーキテクチャ設計を行う場合
- コードレビューで構造を評価する場合
- リファクタリング計画を立てる場合
- 新規コンポーネントの分割を検討する場合
- 依存関係の問題を解決する場合

---

## コンポーネントのまとめ方（凝集度）の3原則

### REP: 再利用・リリース等価の原則

> 再利用の単位とリリースの単位は等価になる

**何を意味するか:**
- 別々で再利用されるものは別々にリリースされるように分割する
- バージョニングはコンポーネント単位で行う

**違反例:**
```
// 悪い: ユーティリティとドメインモデルが同じパッケージ
com.example/
├── utils/
│   ├── StringUtil.java      // 汎用ユーティリティ
│   └── OrderCalculator.java // ドメインロジック
```
→ StringUtilだけ最新版にしたくても、OrderCalculatorも一緒に更新される

**改善例:**
```
// 良い: 再利用単位で分割
com.example/
├── shared-utils/        // 独立してバージョニング
│   └── StringUtil.java
└── order-domain/        // 独立してバージョニング
    └── OrderCalculator.java
```

### CCP: 閉鎖性共通の原則

> 同じ理由、同じタイミングで変更されるクラスをコンポーネントにまとめる

**何を意味するか:**
- コンポーネントレベルでの「単一責任の原則」
- コンポーネントを変更する理由が複数あってはいけない
- 変更の理由やタイミングが異なるクラスは別のコンポーネントに分ける

**判断基準:**
- 「このコンポーネントを変更する理由は何か？」と問う
- 複数の答えが出るなら分割を検討

### CRP: 全再利用の原則

> コンポーネントのユーザーに対して、実際には使わないものへの依存を強要してはいけない

**何を意味するか:**
- あるコンポーネントに依存するなら、そのコンポーネントのすべてのクラスに依存するべき
- 使わないクラスへの依存は、不要な再デプロイを強いる

**違反例:**
```
// 悪い: OrderComponentに注文関連すべてを詰め込む
order-component/
├── Order.java
├── OrderService.java
├── PaymentProcessor.java    // 支払い処理
└── ShippingCalculator.java  // 配送計算
```
→ 注文一覧表示だけしたいのに、支払い・配送の変更でも再デプロイが必要

**改善例:**
```
// 良い: 使用パターンで分割
order-core/           // 注文基本（一覧表示も使用）
├── Order.java
└── OrderRepository.java
order-payment/        // 支払い処理（支払い機能のみ使用）
└── PaymentProcessor.java
order-shipping/       // 配送処理（配送機能のみ使用）
└── ShippingCalculator.java
```

---

## 凝集度3原則のトレードオフ

**重要: 3原則を同時に完全に満たすことはできない。**

```
         REP（再利用性）
           /\
          /  \
         /    \
        /      \
       /________\
    CCP        CRP
（変更の隔離）（精密な依存）
```

| 重視する原則 | 軽視される原則 | コスト |
|------------|--------------|--------|
| REP | CCP | コンポーネントが頻繁に変更される |
| CCP | REP | リリース・再利用が難しくなる |
| CRP | REP | コンポーネント数が増える |

**アーキテクトの判断が重要: 現在の開発フェーズでどの原則を重視すべきか。**

---

## 開発フェーズごとの重視原則

### 開発初期

**重視:** CCP（閉鎖性共通）+ CRP（全再利用）

**理由:**
- 仕様が安定していない
- 「何が再利用できるか」まだ判断できない
- 変更を局所化することが最優先

**アプローチ:**
- 変更理由ごとにコンポーネントを分ける
- 大きすぎるコンポーネントは避ける
- 再利用性は後回し

### 開発中盤以降

**重視:** REP（再利用・リリース等価）+ CRP（全再利用）

**理由:**
- 仕様が安定してきた
- 再利用できる部分が明確になってきた
- 同じ変更を多くのコンポーネントに入れるコストが高くなる

**アプローチ:**
- 再利用可能なコンポーネントを増やす
- 慎重に「何を再利用するか」を判断
- リリース単位を整理

---

## コンポーネントのつなぎ方（結合）の3原則

### 安定度の定義

**安定したコンポーネント:** 多くのコンポーネントから依存されている（変更の影響が大きい）

**不安定なコンポーネント:** 多くのコンポーネントに依存している（影響を受けやすい）

```
安定度の例:
┌─────────────────┐
│ 価格算出サービス  │ ← 最も安定（多くから依存される）
└────────┬────────┘
         │
┌────────▼────────┐
│   ユースケース    │ ← 中程度の安定
└────────┬────────┘
         │
┌────────▼────────┐
│   Webサーバー    │ ← 最も不安定（依存する側）
└─────────────────┘
```

### ADP: 非循環依存関係の原則

> コンポーネント間の依存関係に循環があってはいけない

**理由:** 循環依存はビルド順序を決定不能にし、テストを困難にする

**解決策:**
- 依存関係逆転の原則（DIP）を適用
- 共通インターフェースを抽出

### SDP: 安定依存の原則

> 変動を想定したコンポーネントは、変更しづらいコンポーネントから依存されるべきでない

**何を意味するか:**
- **不安定なコンポーネントから安定したコンポーネントへ依存する**
- 変更しやすくしておきたいコンポーネント（UIなど）から、変更しづらいコンポーネントへ依存する

**違反例:**
```
// 悪い: 安定した層が不安定な層に依存
価格算出サービス → Webサーバー
（変更されたくない）   （頻繁に変わる）
```
→ ビジネスロジックが不安定になる

**改善例:**
```
// 良い: 不安定な層から安定した層へ
Webサーバー → 価格算出サービス
（変更しやすい） （変更されにくい）
```

### SAP: 安定度・抽象度等価の原則

> コンポーネントの抽象度はその安定度と同程度でなければならない

**何を意味するか:**
- **抽象度が高い（上位レベルの方針）→ 安定度が高い**
- **抽象度が低い（下位レベルの詳細）→ 安定度が低い**

**実践方法:**

| 安定度 | 抽象度 | 含めるもの |
|--------|--------|-----------|
| 高い | 高い | インターフェース、抽象クラス、ビジネスルール |
| 中程度 | 中程度 | ユースケース、アプリケーションロジック |
| 低い | 低い | 実装詳細、UI、データベース、フレームワーク |

**良い構造:**
```
┌──────────────────────────────┐
│   インターフェース（抽象）      │ ← 安定・抽象
│   - BusinessRule            │
│   - Repository<I>           │
└──────────────┬───────────────┘
               │
┌──────────────▼───────────────┐
│   ユースケース                 │ ← 中程度
│   - OrderUseCase             │
└──────────────┬───────────────┘
               │
┌──────────────▼───────────────┐
│   実装詳細                    │ ← 不安定・具象
│   - OrderRepositoryImpl      │
│   - MySQLConnection          │
└──────────────────────────────┘
```

---

## プラクティス

### システムの意図を叫ぶ

**良いディレクトリ構造:** ユースケースが見える
```
my-app/
└ modules/
   ├ healthcare-system/    // ヘルスケア機能
   ├ accounting-system/    // 会計機能
   └ inventory-system/     // 在庫管理機能
```

**悪いディレクトリ構造:** フレームワーク名が見える
```
my-app/
└ modules/
   ├ rails-app/            // フレームワーク名
   ├ spring-hibernate/     // フレームワーク名
   └ asp-inventory/        // フレームワーク名
```

### 詳細はプラグイン化する

UI、データベース、フレームワークは**詳細**であり、**プラグイン**として差し替え可能にする。

**実践:**
- ビジネスロジックが詳細に依存するのではなく、詳細がビジネスロジックに依存する
- DIP（依存関係逆転の原則）を適用
- インターフェースをビジネスロジック層に定義

```
// 詳細がプラグイン化された状態
┌──────────────────┐
│  ビジネスロジック   │
│  - Repository<I> │  ← インターフェース
└────────┬─────────┘
         │
    ┌────┴────┬─────────┐
    ▼         ▼         ▼
┌───────┐ ┌───────┐ ┌───────┐
│ MySQL │ │ Redis │ │ Mock  │
│ Impl  │ │ Impl  │ │ Impl  │
└───────┘ └───────┘ └───────┘
   ↑         ↑         ↑
   すべてプラグインとして差し替え可能
```

### Package by Componentを採用する

**推奨:** ビジネスロジックと永続化処理をコンポーネント単位でまとめる

```
// 良い: Package by Component
com.example.order/
├── OrderService.java       // ビジネスロジック
├── OrderRepository.java    // 永続化インターフェース
├── OrderRepositoryImpl.java // 永続化実装
└── Order.java              // ドメインモデル
```

**非推奨:** レイヤー単位でパッケージを切る

```
// 悪い: Package by Layer
com.example/
├── service/
│   ├── OrderService.java
│   └── UserService.java
├── repository/
│   ├── OrderRepository.java
│   └── UserRepository.java
└── domain/
    ├── Order.java
    └── User.java
```

**理由:**
- コンポーネント単位の方が凝集度が高い
- 永続化処理へのアクセスを制限しやすい
- 関連機能をクリーンなインターフェースの向こうに閉じ込められる

---

## レビューチェックリスト

### 凝集度の評価

| チェック項目 | 確認内容 |
|------------|---------|
| 変更理由の単一性 | このコンポーネントを変更する理由は1つか？ |
| 再利用単位の整合性 | 再利用する単位でリリース単位が分かれているか？ |
| 不要な依存の排除 | 使わないクラスへの依存を強制していないか？ |
| 開発フェーズの考慮 | 現在のフェーズに適した原則を重視しているか？ |

### 結合度の評価

| チェック項目 | 確認内容 |
|------------|---------|
| 循環依存の排除 | コンポーネント間に循環依存はないか？ |
| 依存の方向 | 不安定なコンポーネントから安定したコンポーネントへ依存しているか？ |
| 抽象度と安定度 | 抽象度の高いコンポーネントは安定しているか？ |
| プラグイン化 | 詳細（UI、DB）はプラグインとして差し替え可能か？ |

### 構造の評価

| チェック項目 | 確認内容 |
|------------|---------|
| ユースケースの可視性 | ディレクトリ構造からシステムの意図がわかるか？ |
| フレームワークの隠蔽 | フレームワーク名が前面に出ていないか？ |
| Package by Component | コンポーネント単位でパッケージが構成されているか？ |

---

## リファレンス

- [references/principles-summary.md](references/principles-summary.md) - 原則の要約表
- [references/decision-flow.md](references/decision-flow.md) - 設計判断フローチャート

---

## 4層レイヤー構造

クリーンアーキテクチャは、関心の分離を実現するために4層のレイヤー構造を採用する。

### 関心の分離が実現すること

1. **フレームワーク独立**: フレームワークを道具として使い、制約に押し込めない
2. **テスト可能**: ビジネスルールはUI、DB等なしでテストできる
3. **UI独立**: UIを容易に変更できる（Web→コンソール等）
4. **データベース独立**: DBを交換可能（Oracle→Mongo等）
5. **外部機能独立**: ビジネスルールは外側を知らない

### 依存ルール（CRITICAL）

> ソースコードは内側に向かってのみ依存する。内側の円は外側の円について何も知らない。

- 外側の円で宣言された名前を内側から参照してはならない
- 外側の円のデータフォーマットを内側で使ってはならない

### レイヤー対応表

| クリーンアーキテクチャ | DDD（レイヤード） | 含む概念 |
|---------------------|----------------|---------|
| Enterprise Business Rules | ドメイン層 | Entities, Domain Service |
| Application Business Rules | アプリケーション層 | Use Cases, Interactor |
| Interface Adapters | - | Controllers, Presenters, Gateways |
| Frameworks & Drivers | インフラストラクチャ層 | Web, UI, DB, Devices |

---

### Layer 1: Enterprise Business Rules

**位置:** 最も内側（中心の円）

**責務:** ビジネスの概念、状況に関する情報、ビジネスルールを表現

**DDDのドメイン層に相当。** ビジネスソフトウェアの核心。

#### Entities（エンティティ）

> 大規模プロジェクトレベルのビジネスルールをカプセル化する。最も一般的で高レベルなルール。外側の何かが変わっても変わらなさそうなもの。

**特徴:**
- メソッドを持ったオブジェクト、またはデータ構造と関数の集合
- ページナビゲーションやセキュリティの変更の影響を受けない
- アプリケーションの動作変更が影響しない

**DDDとの対応:**
- クリーンアーキテクチャのEntitiesは、DDDのEntity + Value Object + Domain Serviceを包含
- 「同一性」で定義されるオブジェクト（DDD Entity）
- 属性で定義される不変オブジェクト（Value Object）

#### Domain Service（ドメインサービス）

> ドメインで必要な機能をエンティティや値オブジェクトの責務として押しつけると、モデルを歪める場合に作成する。ステートレスな操作。

**いつ使う:**
- 操作がどのエンティティ/値オブジェクトにも紐づかない
- エンティティに押し付けるとモデルが歪む

#### 実装時の確認事項

| 項目 | ガイドライン |
|------|------------|
| リポジトリの扱い | 集約内部からリポジトリを使うことは避ける。ドメインサービスは必要に応じて使える |
| リポジトリIF | ドメイン層で利用する場合、インターフェースはこのレイヤーで定義 |
| パッケージ名 | `domain`, `entity`, `model`等（レイヤー名をそのまま使わない） |

---

### Layer 2: Application Business Rules

**位置:** 中心から2番目

**責務:** アプリケーション固有のビジネスルール。システムの全ユースケースをカプセル化・実装。

**DDDのアプリケーション層に相当。**

#### Use Case / Interactor

> エンティティに入出力するデータの流れを調整し、エンティティに最重要ビジネスルールを使用するように指示する。

**構成要素:**

| 用語 | 説明 |
|------|------|
| Use Case | ユースケースを表すインターフェース（Input Boundary） |
| Interactor | Use Caseインターフェースの実装 |
| Input Data | Use Caseの引数（Controllerから渡される） |
| Output Data | Output Boundaryへ渡す値 |
| Output Boundary | Presenterのインターフェース（実装は外側） |
| Repository | リポジトリのインターフェース（実装は外側） |

**DDDのApplication Serviceとの対応:**
- Use Case = Application Serviceのメソッド
- Interactor = Application Serviceの実装

#### Input/Output Boundaryの関係

**書籍の例:** Use Case（Interactor）がPresenter（Output Boundary）を呼び出す
```
Controller → Use Case → Presenter → View
```

**実装によっては逆:** PresenterがUse Caseを持つ場合もある

```
View → Presenter → Use Case
```

#### 実装時の確認事項

| 項目 | ガイドライン |
|------|------------|
| Input/Output Boundary | Use CaseからPresenterを呼ぶか、PresenterがUse Caseを持つか統一 |
| リポジトリIF | Application層でしか使わないならここで定義も可 |
| 戻り値 | Use Caseが戻り値を返す設計もある |

---

### Layer 3: Interface Adapters

**位置:** 中心から3番目

**責務:** ユースケースとエンティティに便利な形式から、データベースやWebに便利な形式へデータを変換。

**アダプターの集合。** MVCアーキテクチャを完全に内包。

#### 構成要素

| 用語 | 説明 |
|------|------|
| Controller | Webサーバ等からデータを受け取り、Input Dataに変換してUse Caseへ渡す |
| Presenter | InteractorからOutput Dataを受け取り、Viewに適した形にして返す |
| Gateway | Frameworks&Driversからのデータを抽象化（Repository, SQLHandler等） |

#### Gatewayの抽象化粒度

**SQLHandlerの例:** SQLが使えるDBを知っている（依存ルールに反するように見える）

しかし：
- SQL対応DBならORMを変えても影響なし（フレームワーク独立）
- NoSQLに変更してもEnterprise層までは影響なし（データベース独立）

**結論:** あらゆるDBに対応するGatewayは現実的ではない。実用上のメリットを考えて外部知識を適宜注入。

#### 実装時の確認事項

| 項目 | ガイドライン |
|------|------------|
| Gatewayの粒度 | 利用する技術に適した粒度で抽象化 |
| リポジトリIF | Gatewayの一種。必要なレイヤが適宜定義 |
| ORMの扱い | 完全に永続化を隠蔽するならDomain Modelとして扱える可能性も |

---

### Layer 4: Frameworks & Drivers

**位置:** 最も外側

**責務:** フレームワークやツール（DB、Webフレームワーク等）。詳細が詰まっている。

> ウェブは詳細。データベースは詳細。被害が抑えられるように、これらは外側に置いておく。

**特徴:**
- 通常、多くのコードは書かない
- 内側の円と通信するグルーコードのみ
- 具体的な技術実装

#### 構成要素

| 用語 | 説明 |
|------|------|
| Web Framework | Spring, Rails, Express等 |
| Database | MySQL, PostgreSQL, MongoDB等 |
| UI Framework | React, Vue, Android等 |
| External Interfaces | 外部APIクライアント等 |

#### Adapter / Translator（DDD）

| 用語 | 説明 |
|------|------|
| Adapter | HTTPリクエスト等の具体的な処理を行う。Translatorを使って上層で解釈可能な型に変換 |
| Translator | 与えられた型をより上層の型に変換（json→ドメインモデル等） |

---

### その他の構成要素

#### Registry（依存関係解決）

DIPにより依存関係を一方向にするため、インターフェースと実装の紐付けが必要。

**実装方法:**
- 手動で依存関係を解決するコードを書く
- 静的DIツール（Go wire, Android Dagger等）
- 動的DI（Spring等）はアノテーションで自動解決

**ルール:**
- どのレイヤーにも依存して良い
- どのレイヤーからも依存されてはいけない

#### Core / Utility

どのレイヤーからでも利用する汎用的な処理。

**配置:** 別パッケージ（`core`, `utility`, `common`等）

---

## レイヤー間のデータフロー

```
┌─────────────────────────────────────────────────────────────┐
│ Frameworks & Drivers                                         │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │ Web         │  │ DB          │  │ External    │         │
│  │ Framework   │  │ (MySQL等)   │  │ API         │         │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘         │
└─────────┼────────────────┼────────────────┼────────────────┘
          │                │                │
┌─────────▼────────────────▼────────────────▼────────────────┐
│ Interface Adapters                                          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │ Controller  │  │ Gateway     │  │ Presenter   │         │
│  │             │  │ (Repo Impl) │  │             │         │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘         │
└─────────┼────────────────┼────────────────┼────────────────┘
          │                │                │
┌─────────▼────────────────▼────────────────▼────────────────┐
│ Application Business Rules                                  │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ Use Case (Interactor)                               │   │
│  │  - Input Data受取                                   │   │
│  │  - Entity操作                                       │   │
│  │  - Repository利用                                   │   │
│  │  - Output Data出力                                  │   │
│  └────────────────────────┬────────────────────────────┘   │
└───────────────────────────┼────────────────────────────────┘
                            │
┌───────────────────────────▼────────────────────────────────┐
│ Enterprise Business Rules                                   │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │ Entity      │  │ Value       │  │ Domain      │         │
│  │             │  │ Object      │  │ Service     │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
└─────────────────────────────────────────────────────────────┘
```

**依存の方向:** 外側 → 内側（矢印の逆方向）

---

## 設計判断の例

### 例1: ユーティリティクラスの配置

**状況:** `StringUtil`と`DateUtil`をどこに配置するか

**判断:**
1. これらは「汎用的に再利用される」→ REPを重視
2. 変更理由は「ユーティリティ機能の追加・修正」→ CCPも満たす
3. 使用パターンは「一部だけ使うこともある」→ CRPを考慮

**結論:** 文字列系と日時系で別コンポーネントに分割

### 例2: ドメインモデルとリポジトリ

**状況:** `Order`モデルと`OrderRepository`を同じコンポーネントにするか

**判断:**
1. 変更理由は同じ（注文機能の変更）→ CCPを満たす
2. ほぼ常にセットで使われる→ CRPを満たす
3. 再利用単位も同じ→ REPを満たす

**結論:** 同じコンポーネントにまとめる（Package by Component）

### 例3: 認証機能の分離

**状況:** 認証機能をコアから分離するか

**判断:**
1. 認証方式は変わる可能性がある→ プラグイン化すべき
2. ビジネスロジックは認証詳細に依存すべきでない→ DIP適用
3. 抽象度：認証インターフェース > 認証実装→ SAPを満たす

**結論:**
- 認証インターフェースはコア層
- 認証実装（JWT、セッション等）はプラグインとして分離

---

*このスキルは『Clean Architecture 達人に学ぶソフトウェアの構造と設計』（Robert C. Martin著）をベースに作成されました。*

---

## デバッグ情報

### 記録されるイベント

このスキルの実行時に記録されるイベント：

| イベント種別 | 説明 | 記録タイミング |
|-------------|------|---------------|
| session_start | セッション開始 | pi起動時 |
| task_start | タスク開始 | ユーザー依頼受付時 |
| operation_start | 操作開始 | スキル実行開始時 |
| operation_end | 操作終了 | スキル実行完了時 |
| task_end | タスク終了 | タスク完了時 |

### ログ確認方法

```bash
# 今日のログを確認
cat .pi/logs/events-$(date +%Y-%m-%d).jsonl | jq .

# 特定の操作を検索
cat .pi/logs/events-*.jsonl | jq 'select(.eventType == "operation_start")'

# エラーを検索
cat .pi/logs/events-*.jsonl | jq 'select(.data.status == "failure")'
```

### トラブルシューティング

| 症状 | 考えられる原因 | 確認方法 | 解決策 |
|------|---------------|---------|--------|
| 実行が停止する | タイムアウト | ログのdurationMsを確認 | タイムアウト設定を増やす |
| 結果が期待と異なる | 入力パラメータの問題 | paramsを確認 | 入力を修正して再実行 |
| エラーが発生する | リソース不足 | エラーメッセージを確認 | 設定を調整 |

### 関連ファイル

- 実装: `.pi/extensions/clean-architecture.ts`
- ログ: `.pi/logs/events-YYYY-MM-DD.jsonl`
